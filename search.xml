<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Matplotlib学习笔记</title>
    <url>/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Matplotlib 是 Python 的绘图库，它能让使用者很轻松地将数据图形化，并且提供多样化的输出格式。可以用来绘制各种静态，动态，交互式的图表。是一个非常强大的 Python 画图工具，我们可以使用该工具将很多数据通过图表的形式更直观的呈现出来。可以绘制线图、散点图、等高线图、条形图、柱状图、3D 图形、甚至是图形动画等等。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>Matplotlib 通常与 NumPy 和 SciPy（Scientific Python）一起使用， 这种组合广泛用于替代 MatLab，是一个强大的科学计算环境，有助于我们通过 Python 学习数据科学或者机器学习。</p>
<p>SciPy 是一个开源的 Python 算法库和数学工具包。</p>
<p>SciPy 包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>本章节，我们使用 pip 工具来安装 <code>Matplotlib</code> 库，如果还未安装该工具，可以参考 <a href="https://www.runoob.com/w3cnote/python-pip-install-usage.html">Python pip 安装与使用</a>。</p>
<p>升级 pip：</p>
<pre><code class="python">python3 -m pip install -U pip
</code></pre>
<p>安装 <code>matplotlib</code> 库：</p>
<pre><code class="python">python3 -m pip install -U matplotlib
</code></pre>
<p>安装完成后，我们就可以通过 import 来导入<code> matplotlib</code> 库：</p>
<p><code>import matplotlib</code></p>
<p>以下实例，我们通过导入 <code>matplotlib</code> 库，然后查看 <code>matplotlib </code>库的版本号：</p>
<p>实例1:</p>
<p><code>import matplotlib</code></p>
<p><code>print(matplotlib.__version__)</code></p>
<p>执行以上代码，输出结果如下：</p>
<pre><code>3.4.2
</code></pre>
<h2 id="Matplotlib-Pyplot"><a href="#Matplotlib-Pyplot" class="headerlink" title="Matplotlib Pyplot"></a>Matplotlib Pyplot</h2><p>Pyplot 是 Matplotlib 的子库，提供了和 MATLAB 类似的绘图 API。</p>
<p>Pyplot 是常用的绘图模块，能很方便让用户绘制 2D 图表。</p>
<p>Pyplot 包含一系列绘图函数的相关函数，每个函数会对当前的图像进行一些修改，例如：给图像加上标记，生新的图像，在图像中产生新的绘图区域等等。</p>
<p>使用的时候，我们可以使用 import 导入 pyplot 库，并设置一个别名<code> plt</code>：</p>
<p><code>import matplotlib.pyplot as plt</code></p>
<p>这样我们就可以使用 <strong>plt</strong> 来引用 Pyplot 包的方法。</p>
<p>以下实例，我们通过两个坐标 <strong>(0,0)</strong> 到 <strong>(6,100)</strong> 来绘制一条线:</p>
<p>实例1:</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

xpoints = np.array([0, 6])
ypoints = np.array([0, 100])

plt.plot(xpoints, ypoints)
plt.show()
</code></pre>
<p>输出结果如下：</p>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403204022943.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403204022943.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>以上实例中我们使用了 Pyplot 的<code> plot()</code> 函数， <strong>plot()</strong> 函数是绘制二维图形的最基本函数。</p>
<p><strong>plot()</strong> 用于画图它可以绘制点和线，语法格式如下：</p>
<pre><code class="python"># 画单条线
plot([x], y, [fmt], *, data=None, **kwargs)
# 画多条线
plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
</code></pre>
<p>参数说明：</p>
<ul>
<li><strong>x, y：</strong>点或线的节点，x 为 x 轴数据，y 为 y 轴数据，数据可以列表或数组。</li>
<li><strong>fmt：</strong>可选，定义基本格式（如颜色、标记和线条样式）。</li>
<li>*<strong>*kwargs：</strong>可选，用在二维平面图上，设置指定属性，如标签，线的宽度等。</li>
</ul>
<pre><code class="python">&gt;&gt;&gt; plot(x, y)        # 创建 y 中数据与 x 中对应值的二维线图，使用默认样式
&gt;&gt;&gt; plot(x, y, &#39;bo&#39;)  # 创建 y 中数据与 x 中对应值的二维线图，使用蓝色实心圈绘制
&gt;&gt;&gt; plot(y)           # x 的值为 0..N-1
&gt;&gt;&gt; plot(y, &#39;r+&#39;)     # 使用红色 + 号
</code></pre>
<p><strong>颜色字符：</strong>‘b’ 蓝色，’m’ 洋红色，’g’ 绿色，’y’ 黄色，’r’ 红色，’k’ 黑色，’w’ 白色，’c’ 青绿色，’#008000’ RGB 颜色符串。多条曲线不指定颜色时，会自动选择不同颜色。</p>
<p><strong>线型参数：</strong>‘‐’ 实线，’‐‐’ 破折线，’‐.’ 点划线，’:’ 虚线。</p>
<p><strong>标记字符：</strong>‘.’ 点标记，’,’ 像素标记(极小点)，’o’ 实心圈标记，’v’ 倒三角标记，’^’ 上三角标记，’&gt;’ 右三角标记，’&lt;’ 左三角标记…等等。</p>
<p>如果我们只想绘制两个坐标点，而不是一条线，可以使用 <strong>o</strong> 参数，表示一个实心圈的标记。</p>
<p>实例2：绘制坐标 (1, 3) 和 (8, 10) 的两个点</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

xpoints = np.array([1, 8])
ypoints = np.array([3, 10])

plt.plot(xpoints, ypoints, &#39;o&#39;)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403205635489.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403205635489.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>我们也可以绘制任意数量的点，只需确保两个轴上的点数相同即可。</p>
<p>实例3：绘制一条不规则线，坐标为 (1, 3) 、 (2, 8) 、(6, 1) 、(8, 10)，对应的两个数组为：[1, 2, 6, 8] 与 [3, 8, 1, 10]。</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

xpoints = np.array([1, 2, 6, 8])
ypoints = np.array([3, 8, 1, 10])

plt.plot(xpoints, ypoints)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403205827906.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403205827906.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例4：如果我们不指定 x 轴上的点，y只限定范围。</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

ypoints = np.array([3, 10])

plt.plot(ypoints)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403210031623.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403210031623.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>从上图可以看出 x 的值默认设置为 **[0, 1]**。</p>
<p>实例5：如果我们不指定 x 轴上的点，y表明具体的点，则 x 会根据 y 的值来设置为 <strong>0, 1, 2, 3..N-1</strong></p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

ypoints = np.array([3, 8, 1, 10, 5, 7])

plt.plot(ypoints)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403210331668.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403210331668.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例6：以下实例我们绘制一个正弦和余弦图，在 plt.plot() 参数中包含两对 <strong>x,y</strong> 值，第一对是 <strong>x,y</strong>，这对应于正弦函数，第二对是 <strong>x,z</strong>，这对应于余弦函数。</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

x = np.arange(0,4*np.pi,0.1)   # start,stop,step
y = np.sin(x)
z = np.cos(x)
plt.plot(x,y,x,z)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403210514868.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403210514868.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<h2 id="Matplotlib-绘图标记"><a href="#Matplotlib-绘图标记" class="headerlink" title="Matplotlib 绘图标记"></a>Matplotlib 绘图标记</h2><p>绘图过程如果我们想要给坐标自定义一些不一样的标记，就可以使用 <strong>plot()</strong> 方法的 <code>marker </code>参数来定义。</p>
<p>实例1:定义实心圆标记</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

ypoints = np.array([1,3,4,5,8,9,6,1,3,4,5,2,4])

plt.plot(ypoints, marker = &#39;o&#39;)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403212010830.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403212010830.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>marker可以定义的符号如下：</p>
<table>
<thead>
<tr>
<th align="left">标记</th>
<th align="left">符号</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">“.”</td>
<td align="left"><img src="https://www.runoob.com/images/m00.png" class="lazyload" data-srcset="https://www.runoob.com/images/m00.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m00"></td>
<td align="left">点</td>
</tr>
<tr>
<td align="left">“,”</td>
<td align="left"><img src="https://www.runoob.com/images/m01.png" class="lazyload" data-srcset="https://www.runoob.com/images/m01.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m01"></td>
<td align="left">像素点</td>
</tr>
<tr>
<td align="left">“o”</td>
<td align="left"><img src="https://www.runoob.com/images/m02.png" class="lazyload" data-srcset="https://www.runoob.com/images/m02.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m02"></td>
<td align="left">实心圆</td>
</tr>
<tr>
<td align="left">“v”</td>
<td align="left"><img src="https://www.runoob.com/images/m03.png" class="lazyload" data-srcset="https://www.runoob.com/images/m03.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m03"></td>
<td align="left">下三角</td>
</tr>
<tr>
<td align="left">“^”</td>
<td align="left"><img src="https://www.runoob.com/images/m04.png" class="lazyload" data-srcset="https://www.runoob.com/images/m04.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m04"></td>
<td align="left">上三角</td>
</tr>
<tr>
<td align="left">“&lt;”</td>
<td align="left"><img src="https://www.runoob.com/images/m05.png" class="lazyload" data-srcset="https://www.runoob.com/images/m05.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m05"></td>
<td align="left">左三角</td>
</tr>
<tr>
<td align="left">“&gt;”</td>
<td align="left"><img src="https://www.runoob.com/images/m06.png" class="lazyload" data-srcset="https://www.runoob.com/images/m06.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m06"></td>
<td align="left">右三角</td>
</tr>
<tr>
<td align="left">“1”</td>
<td align="left"><img src="https://www.runoob.com/images/m07.png" class="lazyload" data-srcset="https://www.runoob.com/images/m07.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m07"></td>
<td align="left">下三叉</td>
</tr>
<tr>
<td align="left">“2”</td>
<td align="left"><img src="https://www.runoob.com/images/m08.png" class="lazyload" data-srcset="https://www.runoob.com/images/m08.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m08"></td>
<td align="left">上三叉</td>
</tr>
<tr>
<td align="left">“3”</td>
<td align="left"><img src="https://www.runoob.com/images/m09.png" class="lazyload" data-srcset="https://www.runoob.com/images/m09.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m09"></td>
<td align="left">左三叉</td>
</tr>
<tr>
<td align="left">“4”</td>
<td align="left"><img src="https://www.runoob.com/images/m10.png" class="lazyload" data-srcset="https://www.runoob.com/images/m10.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m10"></td>
<td align="left">右三叉</td>
</tr>
<tr>
<td align="left">“8”</td>
<td align="left"><img src="https://www.runoob.com/images/m11.png" class="lazyload" data-srcset="https://www.runoob.com/images/m11.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m11"></td>
<td align="left">八角形</td>
</tr>
<tr>
<td align="left">“s”</td>
<td align="left"><img src="https://www.runoob.com/images/m12.png" class="lazyload" data-srcset="https://www.runoob.com/images/m12.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m12"></td>
<td align="left">正方形</td>
</tr>
<tr>
<td align="left">“p”</td>
<td align="left"><img src="https://www.runoob.com/images/m13.png" class="lazyload" data-srcset="https://www.runoob.com/images/m13.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m13"></td>
<td align="left">五边形</td>
</tr>
<tr>
<td align="left">“P”</td>
<td align="left"><img src="https://www.runoob.com/images/m23.png" class="lazyload" data-srcset="https://www.runoob.com/images/m23.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m23"></td>
<td align="left">加号（填充）</td>
</tr>
<tr>
<td align="left">“*”</td>
<td align="left"><img src="https://www.runoob.com/images/m14.png" class="lazyload" data-srcset="https://www.runoob.com/images/m14.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m14"></td>
<td align="left">星号</td>
</tr>
<tr>
<td align="left">“h”</td>
<td align="left"><img src="https://www.runoob.com/images/m15.png" class="lazyload" data-srcset="https://www.runoob.com/images/m15.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m15"></td>
<td align="left">六边形 1</td>
</tr>
<tr>
<td align="left">“H”</td>
<td align="left"><img src="https://www.runoob.com/images/m16.png" class="lazyload" data-srcset="https://www.runoob.com/images/m16.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m16"></td>
<td align="left">六边形 2</td>
</tr>
<tr>
<td align="left">“+”</td>
<td align="left"><img src="https://www.runoob.com/images/m17.png" class="lazyload" data-srcset="https://www.runoob.com/images/m17.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m17"></td>
<td align="left">加号</td>
</tr>
<tr>
<td align="left">“x”</td>
<td align="left"><img src="https://www.runoob.com/images/m18.png" class="lazyload" data-srcset="https://www.runoob.com/images/m18.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m18"></td>
<td align="left">乘号 x</td>
</tr>
<tr>
<td align="left">“X”</td>
<td align="left"><img src="https://www.runoob.com/images/m24.png" class="lazyload" data-srcset="https://www.runoob.com/images/m24.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m24"></td>
<td align="left">乘号 x (填充)</td>
</tr>
<tr>
<td align="left">“D”</td>
<td align="left"><img src="https://www.runoob.com/images/m19.png" class="lazyload" data-srcset="https://www.runoob.com/images/m19.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m19"></td>
<td align="left">菱形</td>
</tr>
<tr>
<td align="left">“d”</td>
<td align="left"><img src="https://www.runoob.com/images/m20.png" class="lazyload" data-srcset="https://www.runoob.com/images/m20.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m20"></td>
<td align="left">瘦菱形</td>
</tr>
<tr>
<td align="left">“|”</td>
<td align="left"><img src="https://www.runoob.com/images/m21.png" class="lazyload" data-srcset="https://www.runoob.com/images/m21.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m21"></td>
<td align="left">竖线</td>
</tr>
<tr>
<td align="left">“_”</td>
<td align="left"><img src="https://www.runoob.com/images/m22.png" class="lazyload" data-srcset="https://www.runoob.com/images/m22.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m22"></td>
<td align="left">横线</td>
</tr>
<tr>
<td align="left">0 (TICKLEFT)</td>
<td align="left"><img src="https://www.runoob.com/images/m25.png" class="lazyload" data-srcset="https://www.runoob.com/images/m25.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m25"></td>
<td align="left">左横线</td>
</tr>
<tr>
<td align="left">1 (TICKRIGHT)</td>
<td align="left"><img src="https://www.runoob.com/images/m26.png" class="lazyload" data-srcset="https://www.runoob.com/images/m26.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m26"></td>
<td align="left">右横线</td>
</tr>
<tr>
<td align="left">2 (TICKUP)</td>
<td align="left"><img src="https://www.runoob.com/images/m27.png" class="lazyload" data-srcset="https://www.runoob.com/images/m27.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m27"></td>
<td align="left">上竖线</td>
</tr>
<tr>
<td align="left">3 (TICKDOWN)</td>
<td align="left"><img src="https://www.runoob.com/images/m28.png" class="lazyload" data-srcset="https://www.runoob.com/images/m28.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m28"></td>
<td align="left">下竖线</td>
</tr>
<tr>
<td align="left">4 (CARETLEFT)</td>
<td align="left"><img src="https://www.runoob.com/images/m29.png" class="lazyload" data-srcset="https://www.runoob.com/images/m29.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m29"></td>
<td align="left">左箭头</td>
</tr>
<tr>
<td align="left">5 (CARETRIGHT)</td>
<td align="left"><img src="https://www.runoob.com/images/m30.png" class="lazyload" data-srcset="https://www.runoob.com/images/m30.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m30"></td>
<td align="left">右箭头</td>
</tr>
<tr>
<td align="left">6 (CARETUP)</td>
<td align="left"><img src="https://www.runoob.com/images/m31.png" class="lazyload" data-srcset="https://www.runoob.com/images/m31.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m31"></td>
<td align="left">上箭头</td>
</tr>
<tr>
<td align="left">7 (CARETDOWN)</td>
<td align="left"><img src="https://www.runoob.com/images/m32.png" class="lazyload" data-srcset="https://www.runoob.com/images/m32.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m32"></td>
<td align="left">下箭头</td>
</tr>
<tr>
<td align="left">8 (CARETLEFTBASE)</td>
<td align="left"><img src="https://www.runoob.com/images/m33.png" class="lazyload" data-srcset="https://www.runoob.com/images/m33.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m33"></td>
<td align="left">左箭头 (中间点为基准)</td>
</tr>
<tr>
<td align="left">9 (CARETRIGHTBASE)</td>
<td align="left"><img src="https://www.runoob.com/images/m34.png" class="lazyload" data-srcset="https://www.runoob.com/images/m34.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m34"></td>
<td align="left">右箭头 (中间点为基准)</td>
</tr>
<tr>
<td align="left">10 (CARETUPBASE)</td>
<td align="left"><img src="https://www.runoob.com/images/m35.png" class="lazyload" data-srcset="https://www.runoob.com/images/m35.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m35"></td>
<td align="left">上箭头 (中间点为基准)</td>
</tr>
<tr>
<td align="left">11 (CARETDOWNBASE)</td>
<td align="left"><img src="https://www.runoob.com/images/m36.png" class="lazyload" data-srcset="https://www.runoob.com/images/m36.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m36"></td>
<td align="left">下箭头 (中间点为基准)</td>
</tr>
<tr>
<td align="left">“None”, “ “ or “”</td>
<td align="left"></td>
<td align="left">没有任何标记</td>
</tr>
<tr>
<td align="left">‘$…$’</td>
<td align="left"><img src="https://www.runoob.com/images/m37.png" class="lazyload" data-srcset="https://www.runoob.com/images/m37.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="m37"></td>
<td align="left">渲染指定的字符。例如 “$f$” 以字母 f 为标记。</td>
</tr>
</tbody></table>
<p>实例2:定义了 ***** 标记</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

ypoints = np.array([1,3,4,5,8,9,6,1,3,4,5,2,4])

plt.plot(ypoints, marker = &#39;*&#39;)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403212950411.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403212950411.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例3:定义下箭头</p>
<pre><code class="python">import matplotlib.pyplot as plt
import matplotlib.markers

plt.plot([1, 2, 3], marker=matplotlib.markers.CARETDOWNBASE)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403213418027.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403213418027.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<h3 id="fmt-参数"><a href="#fmt-参数" class="headerlink" title="fmt 参数"></a>fmt 参数</h3><p>fmt 参数定义了基本格式，如标记、线条样式和颜色。</p>
<pre><code class="python">fmt = &#39;[marker][line][color]&#39;
</code></pre>
<p>例如 <strong>o:r</strong>，<strong>o</strong> 表示实心圆标记，**:** 表示虚线，<strong>r</strong> 表示颜色为红色。</p>
<p>实例4：</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

ypoints = np.array([6, 2, 13, 10])

plt.plot(ypoints, &#39;o:r&#39;)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403213911622.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403213911622.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>线类型：</p>
<table>
<thead>
<tr>
<th align="left">线类型标记</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">‘-‘</td>
<td align="left">实线</td>
</tr>
<tr>
<td align="left">‘:’</td>
<td align="left">虚线</td>
</tr>
<tr>
<td align="left">‘–’</td>
<td align="left">破折线</td>
</tr>
<tr>
<td align="left">‘-.’</td>
<td align="left">点划线</td>
</tr>
</tbody></table>
<p>颜色类型：</p>
<table>
<thead>
<tr>
<th align="left">颜色标记</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">‘r’</td>
<td align="left">红色</td>
</tr>
<tr>
<td align="left">‘g’</td>
<td align="left">绿色</td>
</tr>
<tr>
<td align="left">‘b’</td>
<td align="left">蓝色</td>
</tr>
<tr>
<td align="left">‘c’</td>
<td align="left">青色</td>
</tr>
<tr>
<td align="left">‘m’</td>
<td align="left">品红</td>
</tr>
<tr>
<td align="left">‘y’</td>
<td align="left">黄色</td>
</tr>
<tr>
<td align="left">‘k’</td>
<td align="left">黑色</td>
</tr>
<tr>
<td align="left">‘w’</td>
<td align="left">白色</td>
</tr>
</tbody></table>
<h3 id="标记大小和颜色"><a href="#标记大小和颜色" class="headerlink" title="标记大小和颜色"></a>标记大小和颜色</h3><p>我们可以自定义标记的大小与颜色，使用的参数分别是：</p>
<ul>
<li>markersize，简写为 <strong>ms</strong>：定义标记的大小。</li>
<li>markerfacecolor，简写为 <strong>mfc</strong>：定义标记内部的颜色。</li>
<li>markeredgecolor，简写为 <strong>mec</strong>：定义标记边框的颜色。</li>
</ul>
<p>实例5：设置标记大小</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

ypoints = np.array([6, 2, 13, 10])

plt.plot(ypoints, marker = &#39;o&#39;, ms = 20)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403215102017.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403215102017.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例6：设置标记外边框颜色</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

ypoints = np.array([6, 2, 13, 10])

plt.plot(ypoints, marker = &#39;o&#39;, ms = 20, mec = &#39;r&#39;)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403215856505.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403215856505.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例7：设置标记内部颜色</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

ypoints = np.array([6, 2, 13, 10])

plt.plot(ypoints, marker = &#39;o&#39;, ms = 20, mfc = &#39;r&#39;)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403220017186.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403220017186.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例8：自定义标记内部与边框的颜色</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

ypoints = np.array([6, 2, 13, 10])
plt.plot(ypoints, marker = &#39;o&#39;, ms = 20, mec = &#39;#4CAF50&#39;, mfc = &#39;#4CAF50&#39;)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403220233003.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403220233003.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<h2 id="Matplotlib-绘图线"><a href="#Matplotlib-绘图线" class="headerlink" title="Matplotlib 绘图线"></a>Matplotlib 绘图线</h2><p>绘图过程如果我们自定义线的样式，包括线的类型、颜色和大小等。</p>
<h3 id="线的类型"><a href="#线的类型" class="headerlink" title="线的类型"></a>线的类型</h3><p>线的类型可以使用 <strong>linestyle</strong> 参数来定义，简写为 <strong>ls</strong></p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">简写</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">‘solid’ (默认)</td>
<td align="left">‘-‘</td>
<td align="left">实线</td>
</tr>
<tr>
<td align="left">‘dotted’</td>
<td align="left">‘:’</td>
<td align="left">点虚线</td>
</tr>
<tr>
<td align="left">‘dashed’</td>
<td align="left">‘–’</td>
<td align="left">破折线</td>
</tr>
<tr>
<td align="left">‘dashdot’</td>
<td align="left">‘-.’</td>
<td align="left">点划线</td>
</tr>
<tr>
<td align="left">‘None’</td>
<td align="left">‘’ 或 ‘ ‘</td>
<td align="left">不画线</td>
</tr>
</tbody></table>
<p>实例1：</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

ypoints = np.array([6, 2, 13, 10])

plt.plot(ypoints, linestyle = &#39;dotted&#39;)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403221432174.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403221432174.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例2：使用简写</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

ypoints = np.array([6, 2, 13, 10])

plt.plot(ypoints, ls = &#39;-.&#39;)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403221604494.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403221604494.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<h3 id="线的颜色"><a href="#线的颜色" class="headerlink" title="线的颜色"></a>线的颜色</h3><p>线的颜色可以使用 <strong>color</strong> 参数来定义，简写为 <strong>c</strong>。</p>
<p>颜色类型：</p>
<table>
<thead>
<tr>
<th align="left">颜色标记</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">‘r’</td>
<td align="left">红色</td>
</tr>
<tr>
<td align="left">‘g’</td>
<td align="left">绿色</td>
</tr>
<tr>
<td align="left">‘b’</td>
<td align="left">蓝色</td>
</tr>
<tr>
<td align="left">‘c’</td>
<td align="left">青色</td>
</tr>
<tr>
<td align="left">‘m’</td>
<td align="left">品红</td>
</tr>
<tr>
<td align="left">‘y’</td>
<td align="left">黄色</td>
</tr>
<tr>
<td align="left">‘k’</td>
<td align="left">黑色</td>
</tr>
<tr>
<td align="left">‘w’</td>
<td align="left">白色</td>
</tr>
</tbody></table>
<p>当然也可以自定义颜色类型，例如：<strong>SeaGreen、#8FBC8F</strong> 等，完整样式可以参考 <a href="https://www.runoob.com/html/html-colorvalues.html">HTML 颜色值</a>。</p>
<p>实例3：</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

ypoints = np.array([6, 2, 13, 10])

plt.plot(ypoints, color = &#39;r&#39;)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403221822295.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403221822295.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例4：</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

ypoints = np.array([6, 2, 13, 10])

plt.plot(ypoints, c = &#39;#8FBC8F&#39;)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403222000966.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403222000966.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例5：</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

ypoints = np.array([6, 2, 13, 10])

plt.plot(ypoints, c = &#39;SeaGreen&#39;)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403222117925.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403222117925.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<h3 id="线的宽度"><a href="#线的宽度" class="headerlink" title="线的宽度"></a>线的宽度</h3><p>线的宽度可以使用 <strong>linewidth</strong> 参数来定义，简写为 <strong>lw</strong>，值可以是浮点数，如：<strong>1</strong>、<strong>2.0</strong>、<strong>5.67</strong> 等</p>
<p>实例6：</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

ypoints = np.array([6, 2, 13, 10])

plt.plot(ypoints, linewidth = &#39;12.5&#39;)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403222318825.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403222318825.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<h3 id="多条线"><a href="#多条线" class="headerlink" title="多条线"></a>多条线</h3><p>plot() 方法中可以包含多对 x,y 值来绘制多条线。</p>
<p>实例7：</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

y1 = np.array([3, 7, 5, 9])
y2 = np.array([6, 2, 13, 10])

plt.plot(y1)
plt.plot(y2)

plt.show()
</code></pre>
<p>从上图可以看出 <strong>x</strong> 的值默认设置为 **[0, 1, 2, 3]**。</p>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403222526935.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403222526935.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例8：</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

x1 = np.array([0, 1, 2, 3])
y1 = np.array([3, 7, 5, 9])
x2 = np.array([0, 1, 2, 3])
y2 = np.array([6, 2, 13, 10])

plt.plot(x1, y1, x2, y2)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403222628227.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220403222628227.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<h2 id="Matplotlib-轴标签和标题"><a href="#Matplotlib-轴标签和标题" class="headerlink" title="Matplotlib 轴标签和标题"></a>Matplotlib 轴标签和标题</h2><p>我们可以使用 <strong>xlabel()</strong> 和 <strong>ylabel()</strong> 方法来设置 x 轴和 y 轴的标签。</p>
<p>实例1：</p>
<pre><code class="python">import numpy as np
import matplotlib.pyplot as plt

x = np.array([1, 2, 3, 4])
y = np.array([1, 4, 9, 16])
plt.plot(x, y)

plt.xlabel(&quot;x - label&quot;)
plt.ylabel(&quot;y - label&quot;)

plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404095612577.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404095612577.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>实例2：使用 <strong>title()</strong> 方法来设置标题:</p>
<pre><code class="python">import numpy as np
import matplotlib.pyplot as plt

x = np.array([1, 2, 3, 4])
y = np.array([1, 4, 9, 16])
plt.plot(x, y)

plt.title(&quot;line chart&quot;)
plt.xlabel(&quot;x - label&quot;)
plt.ylabel(&quot;y - label&quot;)

plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404100123540.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404100123540.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<h3 id="图像中文显示"><a href="#图像中文显示" class="headerlink" title="图像中文显示"></a>图像中文显示</h3><p>Matplotlib 默认情况不支持中文，我们可以使用以下简单的方法来解决。</p>
<p>这里我们使用思源黑体，思源黑体是 Adobe 与 Google 推出的一款开源字体。</p>
<p>官网：<a href="https://source.typekit.com/source-han-serif/cn/">https://source.typekit.com/source-han-serif/cn/</a></p>
<p>GitHub 地址：<a href="https://github.com/adobe-fonts/source-han-sans/tree/release/OTF/SimplifiedChinese">https://github.com/adobe-fonts/source-han-sans/tree/release/OTF/SimplifiedChinese</a></p>
<p>打开链接后，在里面选一个就好了：</p>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404104121709.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404104121709.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>你也可以在网盘下载: <a href="https://pan.baidu.com/s/10-w1JbXZSnx3Tm6uGpPGOw%EF%BC%8C%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9A**yxqu**%E3%80%82">https://pan.baidu.com/s/10-w1JbXZSnx3Tm6uGpPGOw，提取码：**yxqu**。</a></p>
<p>可以下载个 OTF 字体，比如 SourceHanSansSC-Bold.otf，将该文件文件放在当前执行的代码文件中：</p>
<p><code>SourceHanSansSC-Bold.otf</code> 文件放在当前执行的代码文件中。</p>
<p>实例3：</p>
<pre><code class="python">import numpy as np 
from matplotlib import pyplot as plt 
import matplotlib
 
# fname 为 你下载的字体库路径，注意 SourceHanSansSC-Bold.otf 字体的路径
zhfont1 = matplotlib.font_manager.FontProperties(fname=&quot;SourceHanSansSC-Bold.otf&quot;) 
 
x = np.arange(1,11) 
y =  2  * x +  5 
plt.title(&quot;测试&quot;, fontproperties=zhfont1) 
 
# fontproperties 设置中文显示，fontsize 设置字体大小
plt.xlabel(&quot;x标签&quot;, fontproperties=zhfont1)
plt.ylabel(&quot;y标签&quot;, fontproperties=zhfont1)
plt.plot(x,y) 
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404104616081.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404104616081.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p><em>此外，我们还可以使用系统的字体：</em></p>
<pre><code class="python">from matplotlib import pyplot as plt
import matplotlib
a=sorted([f.name for f in matplotlib.font_manager.fontManager.ttflist])

for i in a:
    print(i)
</code></pre>
<p><em>打印出你的 font_manager 的 ttflist 中所有注册的名字，找一个看中文字体例如：STFangsong(仿宋）,然后添加以下代码即可：</em></p>
<pre><code class="python">plt.rcParams[&#39;font.family&#39;]=[&#39;STFangsong&#39;]
</code></pre>
<p>实例4：:自定义字体的样式</p>
<pre><code class="python">import numpy as np
from matplotlib import pyplot as plt
import matplotlib
 
# fname 为 你下载的字体库路径，注意 SourceHanSansSC-Bold.otf 字体的路径，size 参数设置字体大小
zhfont1 = matplotlib.font_manager.FontProperties(fname=&quot;SourceHanSansSC-Bold.otf&quot;, size=18)
font1 = &#123;&#39;color&#39;:&#39;blue&#39;,&#39;size&#39;:20&#125;
font2 = &#123;&#39;color&#39;:&#39;darkred&#39;,&#39;size&#39;:15&#125;
x = np.arange(1,11)
y =  2  * x +  5

# fontdict 可以使用 css 来设置字体样式
plt.title(&quot;菜鸟教程 - 测试&quot;, fontproperties=zhfont1, fontdict = font1)
 
# fontproperties 设置中文显示，fontsize 设置字体大小
plt.xlabel(&quot;x 轴&quot;, fontproperties=zhfont1)
plt.ylabel(&quot;y 轴&quot;, fontproperties=zhfont1)
plt.plot(x,y)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404104841496.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404104841496.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<h3 id="标题与标签的定位"><a href="#标题与标签的定位" class="headerlink" title="标题与标签的定位"></a>标题与标签的定位</h3><p><strong>title()</strong> 方法提供了 <strong>loc</strong> 参数来设置标题显示的位置，可以设置为: **’left’, ‘right’, 和 ‘center’， 默认值为 ‘center’**。</p>
<p><strong>xlabel()</strong> 方法提供了 <strong>loc</strong> 参数来设置 x 轴显示的位置，可以设置为: **’left’, ‘right’, 和 ‘center’， 默认值为 ‘center’**。</p>
<p><strong>ylabel()</strong> 方法提供了 <strong>loc</strong> 参数来设置 y 轴显示的位置，可以设置为: **’bottom’, ‘top’, 和 ‘center’， 默认值为 ‘center’**。</p>
<p>实例5：</p>
<pre><code class="python">import numpy as np
from matplotlib import pyplot as plt
import matplotlib
 
# fname 为 你下载的字体库路径，注意 SourceHanSansSC-Bold.otf 字体的路径，size 参数设置字体大小
zhfont1 = matplotlib.font_manager.FontProperties(fname=&quot;SourceHanSansSC-Bold.otf&quot;, size=18)
font1 = &#123;&#39;color&#39;:&#39;blue&#39;,&#39;size&#39;:20&#125;
font2 = &#123;&#39;color&#39;:&#39;darkred&#39;,&#39;size&#39;:15&#125;
x = np.arange(1,11)
y =  2  * x +  5

# fontdict 可以使用 css 来设置字体样式
plt.title(&quot;菜鸟教程 - 测试&quot;, fontproperties=zhfont1, fontdict = font1, loc=&quot;left&quot;)
 
# fontproperties 设置中文显示，fontsize 设置字体大小
plt.xlabel(&quot;x 轴&quot;, fontproperties=zhfont1, loc=&quot;left&quot;)
plt.ylabel(&quot;y 轴&quot;, fontproperties=zhfont1, loc=&quot;top&quot;)
plt.plot(x,y)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404104916266.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404104916266.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<h2 id="Matplotlib-网格线"><a href="#Matplotlib-网格线" class="headerlink" title="Matplotlib 网格线"></a>Matplotlib 网格线</h2><p>我们可以使用 pyplot 中的 grid() 方法来设置图表中的网格线。</p>
<p>grid() 方法语法格式如下：</p>
<pre><code>matplotlib.pyplot.grid(b=None, which=&#39;major&#39;, axis=&#39;both&#39;, )
</code></pre>
<p><strong>参数说明：</strong></p>
<ul>
<li><p><strong>b</strong>：可选，默认为 None，可以设置布尔值，true 为显示网格线，false 为不显示，如果设置 **kwargs 参数，则值为 true。</p>
</li>
<li><p><strong>which</strong>：可选，可选值有 ‘major’、’minor’ 和 ‘both’，默认为 ‘major’，表示应用更改的网格线。</p>
</li>
<li><p><strong>axis</strong>：可选，设置显示哪个方向的网格线，可以是取 ‘both’（默认），’x’ 或 ‘y’，分别表示两个方向，x 轴方向或 y 轴方向。</p>
</li>
<li><p>*<strong>*kwargs</strong>：可选，设置网格样式，可以是 color&#x3D;’r’, linestyle&#x3D;’-‘ 和 linewidth&#x3D;2，分别表示网格线的颜色，样式和宽度。</p>
</li>
</ul>
<p>实例1：添加一个简单的网格线，参数使用默认值</p>
<pre><code class="python">import numpy as np
import matplotlib.pyplot as plt

x = np.array([1, 2, 3, 4])
y = np.array([1, 4, 9, 16])


plt.title(&quot;RUNOOB grid() Test&quot;)
plt.xlabel(&quot;x - label&quot;)
plt.ylabel(&quot;y - label&quot;)

plt.plot(x, y)

plt.grid()

plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404152016310.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404152016310.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例2:添加一个简单的网格线，axis 参数使用 x，设置 x 轴方向显示网格线</p>
<pre><code class="python">import numpy as np
import matplotlib.pyplot as plt

x = np.array([1, 2, 3, 4])
y = np.array([1, 4, 9, 16])


plt.title(&quot;RUNOOB grid() Test&quot;)
plt.xlabel(&quot;x - label&quot;)
plt.ylabel(&quot;y - label&quot;)

plt.plot(x, y)

plt.grid(axis=&#39;x&#39;) # 设置 y 就在轴方向显示网格线

plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404152129680.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404152129680.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>以下实例添加一个简单的网格线，并设置网格线的样式，格式如下：</p>
<pre><code>grid(color = &#39;color&#39;, linestyle = &#39;linestyle&#39;, linewidth = number)
</code></pre>
<p><strong>参数说明：</strong></p>
<p><strong>color：</strong>‘b’ 蓝色，’m’ 洋红色，’g’ 绿色，’y’ 黄色，’r’ 红色，’k’ 黑色，’w’ 白色，’c’ 青绿色，’#008000’ RGB 颜色符串。</p>
<p><strong>linestyle：</strong>‘‐’ 实线，’‐‐’ 破折线，’‐.’ 点划线，’:’ 虚线。</p>
<p><strong>linewidth</strong>：设置线的宽度，可以设置一个数字。</p>
<p>实例3：</p>
<pre><code class="python">import numpy as np
import matplotlib.pyplot as plt

x = np.array([1, 2, 3, 4])
y = np.array([1, 4, 9, 16])


plt.title(&quot;RUNOOB grid() Test&quot;)
plt.xlabel(&quot;x - label&quot;)
plt.ylabel(&quot;y - label&quot;)

plt.plot(x, y)

plt.grid(color = &#39;r&#39;, linestyle = &#39;--&#39;, linewidth = 0.5)

plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404152316633.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404152316633.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<h2 id="Matplotlib绘制多图"><a href="#Matplotlib绘制多图" class="headerlink" title="Matplotlib绘制多图"></a>Matplotlib绘制多图</h2><p>我们可以使用 pyplot 中的 <strong>subplot()</strong> 和 <strong>subplots()</strong> 方法来绘制多个子图。</p>
<p><strong>subplot()</strong> 方法在绘图时需要指定位置，<strong>subplots()</strong> 方法可以一次生成多个，在调用时只需要调用生成对象的 ax 即可。</p>
<h3 id="subplot"><a href="#subplot" class="headerlink" title="subplot"></a>subplot</h3><pre><code class="python">subplot(nrows, ncols, index, **kwargs)
subplot(pos, **kwargs)
subplot(**kwargs)
subplot(ax)
</code></pre>
<p>以上函数将整个绘图区域分成 nrows 行和 ncols 列，然后从左到右，从上到下的顺序对每个子区域进行编号 <strong>1…N</strong> ，左上的子区域的编号为 1、右下的区域编号为 N，编号可以通过参数 <strong>index</strong> 来设置。</p>
<p>设置 numRows ＝ 1，numCols ＝ 2，就是将图表绘制成 1x2 的图片区域, 对应的坐标为：</p>
<pre><code>(1, 1), (1, 2)
</code></pre>
<p><strong>plotNum ＝ 1</strong>, 表示的坐标为(1, 1), 即第一行第一列的子图。</p>
<p><strong>plotNum ＝ 2</strong>, 表示的坐标为(1, 2), 即第一行第二列的子图。</p>
<p>实例1：</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

#plot 1:
xpoints = np.array([0, 6])
ypoints = np.array([0, 100])

plt.subplot(1, 2, 1)
plt.plot(xpoints,ypoints)
plt.title(&quot;plot 1&quot;)

#plot 2:
x = np.array([1, 2, 3, 4])
y = np.array([1, 4, 9, 16])

plt.subplot(1, 2, 2)
plt.plot(x,y)
plt.title(&quot;plot 2&quot;)

plt.suptitle(&quot;RUNOOB subplot Test&quot;)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404152756053.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404152756053.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>设置 numRows ＝ 2，numCols ＝ 2，就是将图表绘制成 2x2 的图片区域, 对应的坐标为：</p>
<pre><code>(1, 1), (1, 2)
(2, 1), (2, 2)
</code></pre>
<p><strong>plotNum ＝ 1</strong>, 表示的坐标为(1, 1), 即第一行第一列的子图。</p>
<p><strong>plotNum ＝ 2</strong>, 表示的坐标为(1, 2), 即第一行第二列的子图。</p>
<p><strong>plotNum ＝ 3</strong>, 表示的坐标为(2, 1), 即第二行第一列的子图。</p>
<p><strong>plotNum ＝ 4</strong>, 表示的坐标为(2, 2), 即第二行第二列的子图。</p>
<p>实例2：</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

#plot 1:
x = np.array([0, 6])
y = np.array([0, 100])

plt.subplot(2, 2, 1)
plt.plot(x,y)
plt.title(&quot;plot 1&quot;)

#plot 2:
x = np.array([1, 2, 3, 4])
y = np.array([1, 4, 9, 16])

plt.subplot(2, 2, 2)
plt.plot(x,y)
plt.title(&quot;plot 2&quot;)

#plot 3:
x = np.array([1, 2, 3, 4])
y = np.array([3, 5, 7, 9])

plt.subplot(2, 2, 3)
plt.plot(x,y)
plt.title(&quot;plot 3&quot;)

#plot 4:
x = np.array([1, 2, 3, 4])
y = np.array([4, 5, 6, 7])

plt.subplot(2, 2, 4)
plt.plot(x,y)
plt.title(&quot;plot 4&quot;)

plt.suptitle(&quot;RUNOOB subplot Test&quot;)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404152958366.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404152958366.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<h3 id="subplots"><a href="#subplots" class="headerlink" title="subplots()"></a>subplots()</h3><p>subplots() 方法语法格式如下：</p>
<pre><code class="python">matplotlib.pyplot.subplots(nrows=1, ncols=1, *, sharex=False, sharey=False, squeeze=True, subplot_kw=None, gridspec_kw=None, **fig_kw)
</code></pre>
<p><strong>参数说明：</strong></p>
<ul>
<li><strong>nrows</strong>：默认为 1，设置图表的行数。</li>
<li><strong>ncols</strong>：默认为 1，设置图表的列数。</li>
<li><strong>sharex、sharey</strong>：设置 x、y 轴是否共享属性，默认为 false，可设置为 ‘none’、’all’、’row’ 或 ‘col’。 False 或 none 每个子图的 x 轴或 y 轴都是独立的，True 或 ‘all’：所有子图共享 x 轴或 y 轴，’row’ 设置每个子图行共享一个 x 轴或 y 轴，’col’：设置每个子图列共享一个 x 轴或 y 轴。</li>
<li><strong>squeeze</strong>：布尔值，默认为 True，表示额外的维度从返回的 Axes(轴)对象中挤出，对于 N<em>1 或 1</em>N 个子图，返回一个 1 维数组，对于 N*M，N&gt;1 和 M&gt;1 返回一个 2 维数组。如果设置为 False，则不进行挤压操作，返回一个元素为 Axes 实例的2维数组，即使它最终是1x1。</li>
<li><strong>subplot_kw</strong>：可选，字典类型。把字典的关键字传递给 add_subplot() 来创建每个子图。</li>
<li><strong>gridspec_kw</strong>：可选，字典类型。把字典的关键字传递给 GridSpec 构造函数创建子图放在网格里(grid)。</li>
<li>*<strong>*fig_kw</strong>：把详细的关键字参数传给 figure() 函数。</li>
</ul>
<p>实例3：</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

# 创建一些测试数据 -- 图1
x = np.linspace(0, 2*np.pi, 400)
y = np.sin(x**2)

# 创建一个画像和子图 -- 图2
fig, ax = plt.subplots()
ax.plot(x, y)
ax.set_title(&#39;Simple plot&#39;)

# 创建两个子图 -- 图3
f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)
ax1.plot(x, y)
ax1.set_title(&#39;Sharing Y axis&#39;)
ax2.scatter(x, y)

# 创建四个子图 -- 图4
fig, axs = plt.subplots(2, 2, subplot_kw=dict(projection=&quot;polar&quot;))
axs[0, 0].plot(x, y)
axs[1, 1].scatter(x, y)

# 共享 x 轴
plt.subplots(2, 2, sharex=&#39;col&#39;)

# 共享 y 轴
plt.subplots(2, 2, sharey=&#39;row&#39;)

# 共享 x 轴和 y 轴
plt.subplots(2, 2, sharex=&#39;all&#39;, sharey=&#39;all&#39;)

# 这个也是共享 x 轴和 y 轴
plt.subplots(2, 2, sharex=True, sharey=True)

# 创建10 张图，已经存在的则删除
fig, ax = plt.subplots(num=10, clear=True)

plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404153408476.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404153408476.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404153431942.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404153431942.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404153453565.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404153453565.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404153511622.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404153511622.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<h2 id="Matplotlib散点图"><a href="#Matplotlib散点图" class="headerlink" title="Matplotlib散点图"></a>Matplotlib散点图</h2><p>我们可以使用 pyplot 中的 scatter() 方法来绘制散点图。</p>
<p>scatter() 方法语法格式如下：</p>
<pre><code class="python">matplotlib.pyplot.scatter(x, y, s=None, c=None, marker=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, *, edgecolors=None, plotnonfinite=False, data=None, **kwargs)
</code></pre>
<p><strong>参数说明：</strong></p>
<p><strong>x，y</strong>：长度相同的数组，也就是我们即将绘制散点图的数据点，输入数据。</p>
<p><strong>s</strong>：点的大小，默认 20，也可以是个数组，数组每个参数为对应点的大小。</p>
<p><strong>c</strong>：点的颜色，默认蓝色 ‘b’，也可以是个 RGB 或 RGBA 二维行数组。</p>
<p><strong>marker</strong>：点的样式，默认小圆圈 ‘o’。</p>
<p><strong>cmap</strong>：Colormap，默认 None，标量或者是一个 colormap 的名字，只有 c 是一个浮点数数组的时才使用。如果没有申明就是 image.cmap。</p>
<p><strong>norm</strong>：Normalize，默认 None，数据亮度在 0-1 之间，只有 c 是一个浮点数的数组的时才使用。</p>
<p><strong>vmin，vmax：</strong>：亮度设置，在 norm 参数存在时会忽略。</p>
<p><strong>alpha：</strong>：透明度设置，0-1 之间，默认 None，即不透明。</p>
<p><strong>linewidths：</strong>：标记点的长度。</p>
<p><strong>edgecolors：</strong>：颜色或颜色序列，默认为 ‘face’，可选值有 ‘face’, ‘none’, None。</p>
<p><strong>plotnonfinite：</strong>：布尔值，设置是否使用非限定的 c ( inf, -inf 或 nan) 绘制点。</p>
<p>*<strong>*kwargs：</strong>：其他参数。</p>
<p>以下实例 scatter() 函数接收长度相同的数组参数，一个用于 x 轴的值，另一个用于 y 轴上的值：</p>
<p>实例1：</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

x = np.array([1, 2, 3, 4, 5, 6, 7, 8])
y = np.array([1, 4, 9, 16, 7, 11, 23, 18])

plt.scatter(x, y)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404155337371.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404155337371.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例2：设置图标大小</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

x = np.array([1, 2, 3, 4, 5, 6, 7, 8])
y = np.array([1, 4, 9, 16, 7, 11, 23, 18])
sizes = np.array([20,50,100,200,500,1000,60,90])
plt.scatter(x, y, s=sizes)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404155550197.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404155550197.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例3：自定义点的颜色</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

x = np.array([1, 2, 3, 4, 5, 6, 7, 8])
y = np.array([1, 4, 9, 16, 7, 11, 23, 18])
colors = np.array([&quot;red&quot;,&quot;green&quot;,&quot;black&quot;,&quot;orange&quot;,&quot;purple&quot;,&quot;beige&quot;,&quot;cyan&quot;,&quot;magenta&quot;])

plt.scatter(x, y, c=colors)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404155740263.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404155740263.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例4：设置两组散点图</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

x = np.array([5,7,8,7,2,17,2,9,4,11,12,9,6])
y = np.array([99,86,87,88,111,86,103,87,94,78,77,85,86])
plt.scatter(x, y, color = &#39;hotpink&#39;)

x = np.array([2,2,8,1,15,8,12,9,7,3,11,4,7,14,12])
y = np.array([100,105,84,105,90,99,90,95,94,100,79,112,91,80,85])
plt.scatter(x, y, color = &#39;#88c999&#39;)

plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404155923033.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404155923033.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例5：使用随机数来设置散点图</p>
<pre><code class="python">import numpy as np
import matplotlib.pyplot as plt

# 随机数生成器的种子
np.random.seed(19680801)


N = 50
x = np.random.rand(N)
y = np.random.rand(N)
colors = np.random.rand(N)
area = (30 * np.random.rand(N))**2  # 0 to 15 point radii

plt.scatter(x, y, s=area, c=colors, alpha=0.5) # 设置颜色及透明度

plt.title(&quot;RUNOOB Scatter Test&quot;) # 设置标题

plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404160218777.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404160218777.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<h3 id="颜色条Colormap"><a href="#颜色条Colormap" class="headerlink" title="颜色条Colormap"></a>颜色条Colormap</h3><p>Matplotlib 模块提供了很多可用的颜色条。</p>
<p>颜色条就像一个颜色列表，其中每种颜色都有一个范围从 0 到 100 的值。</p>
<p>下面是一个颜色条的例子：</p>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404160411035.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404160411035.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例6：设置颜色条需要使用 cmap 参数，默认值为 ‘viridis’，之后颜色值设置为 0 到 100 的数组</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

x = np.array([5,7,8,7,2,17,2,9,4,11,12,9,6])
y = np.array([99,86,87,88,111,86,103,87,94,78,77,85,86])
colors = np.array([0, 10, 20, 30, 40, 45, 50, 55, 60, 70, 80, 90, 100])

plt.scatter(x, y, c=colors, cmap=&#39;viridis&#39;)

plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404160555429.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404160555429.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例7：如果要显示颜色条，需要使用 <strong>plt.colorbar()</strong> 方法</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

x = np.array([5,7,8,7,2,17,2,9,4,11,12,9,6])
y = np.array([99,86,87,88,111,86,103,87,94,78,77,85,86])
colors = np.array([0, 10, 20, 30, 40, 45, 50, 55, 60, 70, 80, 90, 100])

plt.scatter(x, y, c=colors, cmap=&#39;viridis&#39;)

plt.colorbar()

plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404160751739.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404160751739.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例8：换个颜色条参数， cmap 设置为 <strong>afmhot_r</strong></p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

x = np.array([5,7,8,7,2,17,2,9,4,11,12,9,6])
y = np.array([99,86,87,88,111,86,103,87,94,78,77,85,86])
colors = np.array([0, 10, 20, 30, 40, 45, 50, 55, 60, 70, 80, 90, 100])

plt.scatter(x, y, c=colors, cmap=&#39;afmhot_r&#39;)
plt.colorbar()
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404160958004.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404160958004.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>颜色条参数值可以是以下值：</p>
<table>
<thead>
<tr>
<th align="left">颜色名称</th>
<th align="left">保留关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Accent</td>
<td align="left">Accent_r</td>
</tr>
<tr>
<td align="left">Blues</td>
<td align="left">Blues_r</td>
</tr>
<tr>
<td align="left">BrBG</td>
<td align="left">BrBG_r</td>
</tr>
<tr>
<td align="left">BuGn</td>
<td align="left">BuGn_r</td>
</tr>
<tr>
<td align="left">BuPu</td>
<td align="left">BuPu_r</td>
</tr>
<tr>
<td align="left">CMRmap</td>
<td align="left">CMRmap_r</td>
</tr>
<tr>
<td align="left">Dark2</td>
<td align="left">Dark2_r</td>
</tr>
<tr>
<td align="left">GnBu</td>
<td align="left">GnBu_r</td>
</tr>
<tr>
<td align="left">Greens</td>
<td align="left">Greens_r</td>
</tr>
<tr>
<td align="left">Greys</td>
<td align="left">Greys_r</td>
</tr>
<tr>
<td align="left">OrRd</td>
<td align="left">OrRd_r</td>
</tr>
<tr>
<td align="left">Oranges</td>
<td align="left">Oranges_r</td>
</tr>
<tr>
<td align="left">PRGn</td>
<td align="left">PRGn_r</td>
</tr>
<tr>
<td align="left">Paired</td>
<td align="left">Paired_r</td>
</tr>
<tr>
<td align="left">Pastel1</td>
<td align="left">Pastel1_r</td>
</tr>
<tr>
<td align="left">Pastel2</td>
<td align="left">Pastel2_r</td>
</tr>
<tr>
<td align="left">PiYG</td>
<td align="left">PiYG_r</td>
</tr>
<tr>
<td align="left">PuBu</td>
<td align="left">PuBu_r</td>
</tr>
<tr>
<td align="left">PuBuGn</td>
<td align="left">PuBuGn_r</td>
</tr>
<tr>
<td align="left">PuOr</td>
<td align="left">PuOr_r</td>
</tr>
<tr>
<td align="left">PuRd</td>
<td align="left">PuRd_r</td>
</tr>
<tr>
<td align="left">Purples</td>
<td align="left">Purples_r</td>
</tr>
<tr>
<td align="left">RdBu</td>
<td align="left">RdBu_r</td>
</tr>
<tr>
<td align="left">RdGy</td>
<td align="left">RdGy_r</td>
</tr>
<tr>
<td align="left">RdPu</td>
<td align="left">RdPu_r</td>
</tr>
<tr>
<td align="left">RdYlBu</td>
<td align="left">RdYlBu_r</td>
</tr>
<tr>
<td align="left">RdYlGn</td>
<td align="left">RdYlGn_r</td>
</tr>
<tr>
<td align="left">Reds</td>
<td align="left">Reds_r</td>
</tr>
<tr>
<td align="left">Set1</td>
<td align="left">Set1_r</td>
</tr>
<tr>
<td align="left">Set2</td>
<td align="left">Set2_r</td>
</tr>
<tr>
<td align="left">Set3</td>
<td align="left">Set3_r</td>
</tr>
<tr>
<td align="left">Spectral</td>
<td align="left">Spectral_r</td>
</tr>
<tr>
<td align="left">Wistia</td>
<td align="left">Wistia_r</td>
</tr>
<tr>
<td align="left">YlGn</td>
<td align="left">YlGn_r</td>
</tr>
<tr>
<td align="left">YlGnBu</td>
<td align="left">YlGnBu_r</td>
</tr>
<tr>
<td align="left">YlOrBr</td>
<td align="left">YlOrBr_r</td>
</tr>
<tr>
<td align="left">YlOrRd</td>
<td align="left">YlOrRd_r</td>
</tr>
<tr>
<td align="left">afmhot</td>
<td align="left">afmhot_r</td>
</tr>
<tr>
<td align="left">autumn</td>
<td align="left">autumn_r</td>
</tr>
<tr>
<td align="left">binary</td>
<td align="left">binary_r</td>
</tr>
<tr>
<td align="left">bone</td>
<td align="left">bone_r</td>
</tr>
<tr>
<td align="left">brg</td>
<td align="left">brg_r</td>
</tr>
<tr>
<td align="left">bwr</td>
<td align="left">bwr_r</td>
</tr>
<tr>
<td align="left">cividis</td>
<td align="left">cividis_r</td>
</tr>
<tr>
<td align="left">cool</td>
<td align="left">cool_r</td>
</tr>
<tr>
<td align="left">coolwarm</td>
<td align="left">coolwarm_r</td>
</tr>
<tr>
<td align="left">copper</td>
<td align="left">copper_r</td>
</tr>
<tr>
<td align="left">cubehelix</td>
<td align="left">cubehelix_r</td>
</tr>
<tr>
<td align="left">flag</td>
<td align="left">flag_r</td>
</tr>
<tr>
<td align="left">gist_earth</td>
<td align="left">gist_earth_r</td>
</tr>
<tr>
<td align="left">gist_gray</td>
<td align="left">gist_gray_r</td>
</tr>
<tr>
<td align="left">gist_heat</td>
<td align="left">gist_heat_r</td>
</tr>
<tr>
<td align="left">gist_ncar</td>
<td align="left">gist_ncar_r</td>
</tr>
<tr>
<td align="left">gist_rainbow</td>
<td align="left">gist_rainbow_r</td>
</tr>
<tr>
<td align="left">gist_stern</td>
<td align="left">gist_stern_r</td>
</tr>
<tr>
<td align="left">gist_yarg</td>
<td align="left">gist_yarg_r</td>
</tr>
<tr>
<td align="left">gnuplot</td>
<td align="left">gnuplot_r</td>
</tr>
<tr>
<td align="left">gnuplot2</td>
<td align="left">gnuplot2_r</td>
</tr>
<tr>
<td align="left">gray</td>
<td align="left">gray_r</td>
</tr>
<tr>
<td align="left">hot</td>
<td align="left">hot_r</td>
</tr>
<tr>
<td align="left">hsv</td>
<td align="left">hsv_r</td>
</tr>
<tr>
<td align="left">inferno</td>
<td align="left">inferno_r</td>
</tr>
<tr>
<td align="left">jet</td>
<td align="left">jet_r</td>
</tr>
<tr>
<td align="left">magma</td>
<td align="left">magma_r</td>
</tr>
<tr>
<td align="left">nipy_spectral</td>
<td align="left">nipy_spectral_r</td>
</tr>
<tr>
<td align="left">ocean</td>
<td align="left">ocean_r</td>
</tr>
<tr>
<td align="left">pink</td>
<td align="left">pink_r</td>
</tr>
<tr>
<td align="left">plasma</td>
<td align="left">plasma_r</td>
</tr>
<tr>
<td align="left">prism</td>
<td align="left">prism_r</td>
</tr>
<tr>
<td align="left">rainbow</td>
<td align="left">rainbow_r</td>
</tr>
<tr>
<td align="left">seismic</td>
<td align="left">seismic_r</td>
</tr>
<tr>
<td align="left">spring</td>
<td align="left">spring_r</td>
</tr>
<tr>
<td align="left">summer</td>
<td align="left">summer_r</td>
</tr>
<tr>
<td align="left">tab10</td>
<td align="left">tab10_r</td>
</tr>
<tr>
<td align="left">tab20</td>
<td align="left">tab20_r</td>
</tr>
<tr>
<td align="left">tab20b</td>
<td align="left">tab20b_r</td>
</tr>
<tr>
<td align="left">tab20c</td>
<td align="left">tab20c_r</td>
</tr>
<tr>
<td align="left">terrain</td>
<td align="left">terrain_r</td>
</tr>
<tr>
<td align="left">twilight</td>
<td align="left">twilight_r</td>
</tr>
<tr>
<td align="left">twilight_shifted</td>
<td align="left">twilight_shifted_r</td>
</tr>
<tr>
<td align="left">viridis</td>
<td align="left">viridis_r</td>
</tr>
<tr>
<td align="left">winter</td>
<td align="left">winter_r</td>
</tr>
</tbody></table>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404161117677.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404161117677.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404161139138.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404161139138.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404161157754.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404161157754.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<h2 id="Matplotlib柱形图"><a href="#Matplotlib柱形图" class="headerlink" title="Matplotlib柱形图"></a>Matplotlib柱形图</h2><p>我们可以使用 pyplot 中的 bar() 方法来绘制柱形图。</p>
<p>bar() 方法语法格式如下：</p>
<pre><code class="python">matplotlib.pyplot.bar(x, height, width=0.8, bottom=None, *, align=&#39;center&#39;, data=None, **kwargs)
</code></pre>
<p><strong>参数说明：</strong></p>
<p><strong>x</strong>：浮点型数组，柱形图的 x 轴数据。</p>
<p><strong>height</strong>：浮点型数组，柱形图的高度。</p>
<p><strong>width</strong>：浮点型数组，柱形图的宽度。</p>
<p><strong>bottom</strong>：浮点型数组，底座的 y 坐标，默认 0。</p>
<p><strong>align</strong>：柱形图与 x 坐标的对齐方式，’center’ 以 x 位置为中心，这是默认值。 ‘edge’：将柱形图的左边缘与 x 位置对齐。要对齐右边缘的条形，可以传递负数的宽度值及 align&#x3D;’edge’。</p>
<p>*<strong>*kwargs：</strong>：其他参数。</p>
<p>实例1：简单实用 bar() 来创建一个柱形图</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

x = np.array([&quot;Runoob-1&quot;, &quot;Runoob-2&quot;, &quot;Runoob-3&quot;, &quot;C-RUNOOB&quot;])
y = np.array([12, 22, 6, 18])

plt.bar(x,y)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404162147295.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404162147295.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例2：垂直方向的柱形图可以使用 <strong>barh()</strong> 方法来设置</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

x = np.array([&quot;Runoob-1&quot;, &quot;Runoob-2&quot;, &quot;Runoob-3&quot;, &quot;C-RUNOOB&quot;])
y = np.array([12, 22, 6, 18])

plt.barh(x,y)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404162341451.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404162341451.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例3：设置柱形图颜色</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

x = np.array([&quot;Runoob-1&quot;, &quot;Runoob-2&quot;, &quot;Runoob-3&quot;, &quot;C-RUNOOB&quot;])
y = np.array([12, 22, 6, 18])

plt.bar(x, y, color = &quot;#4CAF50&quot;)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404162449487.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404162449487.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例4：自定义各个柱形的颜色</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

x = np.array([&quot;Runoob-1&quot;, &quot;Runoob-2&quot;, &quot;Runoob-3&quot;, &quot;C-RUNOOB&quot;])
y = np.array([12, 22, 6, 18])

plt.bar(x, y,  color = [&quot;#4CAF50&quot;,&quot;red&quot;,&quot;hotpink&quot;,&quot;#556B2F&quot;])
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404162554129.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404162554129.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例5：设置柱形图宽度，<strong>bar()</strong> 方法使用 <strong>width</strong> 设置</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

x = np.array([&quot;Runoob-1&quot;, &quot;Runoob-2&quot;, &quot;Runoob-3&quot;, &quot;C-RUNOOB&quot;])
y = np.array([12, 22, 6, 18])

plt.bar(x, y, width = 0.1)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404162717588.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404162717588.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例6：<strong>barh()</strong> 方法使用 <strong>height</strong> 设置 height</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

x = np.array([&quot;Runoob-1&quot;, &quot;Runoob-2&quot;, &quot;Runoob-3&quot;, &quot;C-RUNOOB&quot;])
y = np.array([12, 22, 6, 18])

plt.barh(x, y, height = 0.1)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404162753714.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404162753714.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<h2 id="Matplotlib饼图"><a href="#Matplotlib饼图" class="headerlink" title="Matplotlib饼图"></a>Matplotlib饼图</h2><p>我们可以使用 pyplot 中的 pie() 方法来绘制饼图。</p>
<p>pie() 方法语法格式如下：</p>
<pre><code class="python">matplotlib.pyplot.pie(x, explode=None, labels=None, colors=None, autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1, startangle=0, radius=1, counterclock=True, wedgeprops=None, textprops=None, center=0, 0, frame=False, rotatelabels=False, *, normalize=None, data=None)[source]
</code></pre>
<p><strong>参数说明：</strong></p>
<p><strong>x</strong>：浮点型数组，表示每个扇形的面积。</p>
<p><strong>explode</strong>：数组，表示各个扇形之间的间隔，默认值为0。</p>
<p><strong>labels</strong>：列表，各个扇形的标签，默认值为 None。</p>
<p><strong>colors</strong>：数组，表示各个扇形的颜色，默认值为 None。</p>
<p><strong>autopct</strong>：设置饼图内各个扇形百分比显示格式，**%d%%** 整数百分比，**%0.1f** 一位小数， <strong>%0.1f%%</strong> 一位小数百分比， <strong>%0.2f%%</strong> 两位小数百分比。</p>
<p><strong>labeldistance</strong>：标签标记的绘制位置，相对于半径的比例，默认值为 1.1，如 <strong>&lt;1</strong>则绘制在饼图内侧。</p>
<p><strong>pctdistance：</strong>：类似于 labeldistance，指定 autopct 的位置刻度，默认值为 0.6。</p>
<p><strong>shadow：</strong>：布尔值 True 或 False，设置饼图的阴影，默认为 False，不设置阴影。</p>
<p><strong>radius：</strong>：设置饼图的半径，默认为 1。</p>
<p><strong>startangle：</strong>：起始绘制饼图的角度，默认为从 x 轴正方向逆时针画起，如设定 &#x3D;90 则从 y 轴正方向画起。</p>
<p><strong>counterclock</strong>：布尔值，设置指针方向，默认为 True，即逆时针，False 为顺时针。</p>
<p><strong>wedgeprops</strong> ：字典类型，默认值 None。参数字典传递给 wedge 对象用来画一个饼图。例如：wedgeprops&#x3D;{‘linewidth’:5} 设置 wedge 线宽为5。</p>
<p><strong>textprops</strong> ：字典类型，默认值为：None。传递给 text 对象的字典参数，用于设置标签（labels）和比例文字的格式。</p>
<p><strong>center</strong> ：浮点类型的列表，默认值：(0,0)。用于设置图标中心位置。</p>
<p><strong>frame</strong> ：布尔类型，默认值：False。如果是 True，绘制带有表的轴框架。</p>
<p><strong>rotatelabels</strong> ：布尔类型，默认为 False。如果为 True，旋转每个 label 到指定的角度。</p>
<p>实例1：简单实用 pie() 来创建一个柱形图</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

y = np.array([35, 25, 25, 15])

plt.pie(y)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404165657025.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404165657025.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例2：设置饼图各个扇形的标签与颜色</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

y = np.array([35, 25, 25, 15])

plt.pie(y,
        labels=[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;], # 设置饼图标签
        colors=[&quot;#d5695d&quot;, &quot;#5d8ca8&quot;, &quot;#65a479&quot;, &quot;#a564c9&quot;], # 设置饼图颜色
       )
plt.title(&quot;RUNOOB Pie Test&quot;) # 设置标题
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404165759838.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404165759838.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>实例3：突出显示第二个扇形，并格式化输出百分比</p>
<pre><code class="python">import matplotlib.pyplot as plt
import numpy as np

y = np.array([35, 25, 25, 15])

plt.pie(y,
        labels=[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;], # 设置饼图标签
        colors=[&quot;#d5695d&quot;, &quot;#5d8ca8&quot;, &quot;#65a479&quot;, &quot;#a564c9&quot;], # 设置饼图颜色
        explode=(0, 0.2, 0, 0), # 第二部分突出显示，值越大，距离中心越远
        autopct=&#39;%.2f%%&#39;, # 格式化输出百分比
       )
plt.title(&quot;RUNOOB Pie Test&quot;)
plt.show()
</code></pre>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404170000561.png" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220404170000561.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p><strong>注意：</strong>默认情况下，第一个扇形的绘制是从 x 轴开始并逆时针移动：</p>
<img src="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/03D59143-B345-4B36-A7CD-53F698AB5284.jpg" class="lazyload" data-srcset="/2022/04/03/CN/Matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/03D59143-B345-4B36-A7CD-53F698AB5284.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:50%;">]]></content>
  </entry>
  <entry>
    <title>MySQL学习笔记</title>
    <url>/2022/03/26/CN/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="MySQL入门教程"><a href="#MySQL入门教程" class="headerlink" title="MySQL入门教程"></a>MySQL入门教程</h2><h3 id="什么是数据库"><a href="#什么是数据库" class="headerlink" title="什么是数据库"></a>什么是数据库</h3><p>数据库是按照数据结构来组织、存储和管理数据的仓库</p>
<p>关系型数据库：建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据</p>
<p>RDBMS即关系数据库管理系统的特点：</p>
<p>1.数据以表格的形式出现</p>
<p>2.每行为各种记录名称</p>
<p>3.每列为记录名称所对应的数据域</p>
<p>4.许多行和列组成一张表单</p>
<p>5.若干的表单组成数据库</p>
<h3 id="RDBMS相关概念"><a href="#RDBMS相关概念" class="headerlink" title="RDBMS相关概念"></a>RDBMS相关概念</h3><p>·</p>
<h3 id="MySQL创建数据表"><a href="#MySQL创建数据表" class="headerlink" title="MySQL创建数据表"></a>MySQL创建数据表</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>CREATE TABLE table_name (column_name column_type)</code></p>
<p>举例：在W3CSCHOOL数据库中创建数据表w3cschool_tbl:</p>
<pre><code class="mysql">CREATE TABLE IF NOT EXISTS tutorials_tbl(
    tutorial_id INT NOT NULL AUTO_INCREMENT,
    tutorial_title VARCHAR(100) NOT NULL,
    tutorial_author VARCHAR(40) NOT NULL,
    submission_date DATE,
    PRIMARY KEY (tutorial_id)
    );
</code></pre>
<p>注：</p>
<p>·如果你不想字段为NULL可以设置字段的属性为NOT NULL,在操作数据库如果输入该字段的数据为NULL,则会报错。</p>
<p>·AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。</p>
<p>·PRIMARY KEY关键字用于定义列为主键。你可以使用多列来定义主键，列间以逗号分隔。</p>
<h3 id="MySQL删除数据表"><a href="#MySQL删除数据表" class="headerlink" title="MySQL删除数据表"></a>MySQL删除数据表</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p><code>DROP TABLE table_name</code></p>
<h3 id="MySQL插入数据"><a href="#MySQL插入数据" class="headerlink" title="MySQL插入数据"></a>MySQL插入数据</h3><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><pre><code class="mysql">INSERT INTO table_name(field1, field2, ...fieldN)
                      VALUES
                      (value1, value2, ...valueN);
</code></pre>
<p>举例：使用SQL INSERT INTO语句向MySQL数据表w3cschool_tbl插入数据：</p>
<pre><code class="mysql">INSERT INTO w3cschool_tbl
(w3cschool_title, w3cschool_author, submission_date)
VALUES
(&quot;Learn PHP&quot;, &quot;John Poul&quot;, NOW());
</code></pre>
<h3 id="MySQL查询数据"><a href="#MySQL查询数据" class="headerlink" title="MySQL查询数据"></a>MySQL查询数据</h3><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><pre><code class="mysql">SELECT column_name, column_name
FROM table_name
[WHERE Clause]
[OFFSET M][LIMIT N]
</code></pre>
<p>注：</p>
<p>·查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分隔，并使用WHERE语句来设定查询条件。</p>
<p>·SELECT命令可以读取一条或者多条记录。</p>
<p>·你可以使用星号(*)来代替其他字段，SELECT语句会返回表的所有字段数据。</p>
<p>·你可以使用WHERE语句来包含任何条件。</p>
<p>·你可以通过OFFSET指定SELECT语句开始查询的数据偏移量，默认偏移量为0。</p>
<p>·你可以使用LIMIT属性来设定返回的记录数。</p>
<p>举例：通过SQL SELECT命令来获取MySQL数据表w3cschool_tbl的数据：</p>
<p><code>SELECT * from w3cschool_tbl;</code></p>
<h3 id="MySQL-where子句"><a href="#MySQL-where子句" class="headerlink" title="MySQL where子句"></a>MySQL where子句</h3><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><pre><code class="mysql">SELECT field1, field2, ...fieldN
FROM table_name1, table_name2...
[WHERE condition1 [[AND][OR]] condition2...]
</code></pre>
<p>注：</p>
<p>·查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分隔，并使用WHERE语句来设定查询条件。</p>
<p>·你可以在WHERE子句中指定任何条件。</p>
<p>·你可以使用AND或者OR指定一个或多个条件。</p>
<p>·WHERE子句也可以运用于SQL的DELETE或UPDATE命令。</p>
<p>·WHERE子句类似于程序中的if条件，根据MySQL表中的字段值来读取指定的数据。</p>
<p>操作符列表，实例假定A&#x3D;10,B&#x3D;20:</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x3D;</td>
<td>等号，检测两个值是否相等，如果相等返回True</td>
<td>(A&#x3D;B)返回false</td>
</tr>
<tr>
<td align="center">&lt;&gt;或！&#x3D;</td>
<td>不等于，检测两个值是否相等，如果不相等返回True</td>
<td>（A!&#x3D;B)返归true</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td>大于号，检测左边的值是否大于右边的值，如果左边的值大于右边的值返回True</td>
<td>(A&gt;B)返回false</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td>小于号，检测左边的值是否小于右边的值，如果左边的值小于右边的值返回True</td>
<td>(A&lt;B)返回true</td>
</tr>
<tr>
<td align="center">&gt;&#x3D;</td>
<td>大于等于号，检测左边的值是否大于等于右边的值，如果左边的值大于或等于右边的值返回True</td>
<td>(A&gt;&#x3D;B)返回false</td>
</tr>
<tr>
<td align="center">&lt;&#x3D;</td>
<td>小于等于号，检测左边的值是否小于或等于右边的值，如果左边的值小于或等于右边的值返回True</td>
<td>(A&lt;&#x3D;B)返回true</td>
</tr>
</tbody></table>
<p>举例：读取w3cschool_tbl表中w3cschool_author字段值为Sanjay的所有记录：</p>
<p><code>SELECT * from w3cschool_tbl WHERE w3cschool_author=&#39;Sanjay&#39;;</code></p>
<p>除非你使用LIKE来比较字符串，否则MySQL的WHERE子句的字符串比较是不区分大小写的。你可以使用BINARY关键字来设定WHERE子句的紫福春是区分大小写的。</p>
<p><code>SELECT * from w3cschool_tbl WHERE BINARY w3cschool_author=&#39;sanjay&#39;;</code></p>
<h3 id="MySQL-UPDATE查询"><a href="#MySQL-UPDATE查询" class="headerlink" title="MySQL UPDATE查询"></a>MySQL UPDATE查询</h3><h4 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h4><pre><code class="mysql">UPDATE table_name SET field1=new-value1, field2=new-value2

[WHERE Clause]
</code></pre>
<p>注：</p>
<p>·你可以同时更新一个或多个字段</p>
<p>·你可以在WHERE字句中指定任何条件</p>
<p>·你可以在一个单独表中同时更新数据</p>
<p>当你需要更新表中指定行的数据时，WHERE子句是非常有用的。</p>
<p>举例：更新数据表中w3cschool_id为3的w3cschool_title字段值：</p>
<pre><code class="mysql">UPDATE w3cschool_tbl
SET w3cschool_title=&#39;Learning JAVA&#39;
WHERE w3cschool_id=3;
</code></pre>
<h3 id="MySQL-DELETE语句"><a href="#MySQL-DELETE语句" class="headerlink" title="MySQL DELETE语句"></a>MySQL DELETE语句</h3><h4 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h4><p><code>DELETE FROM table_name [WHERE Clause]</code></p>
<p>注：</p>
<p>·如果没有指定WHERE子句，MySQL表中的所有记录将被删除</p>
<p>·你可以在WHERE字句中指定任何条件</p>
<p>·你可以在单个表中一次性删除记录</p>
<p>当你想删除数据表中的指定记录时，WHERE子句是非常有用的</p>
<p>举例：删除w3cschool_tbl表中w3cschool_id为3的记录：</p>
<pre><code class="mysql">DELETE FROM w3cschool_tbl WHERE w3cschool_id=3;
</code></pre>
<h3 id="MySQL-LIKE子句"><a href="#MySQL-LIKE子句" class="headerlink" title="MySQL LIKE子句"></a>MySQL LIKE子句</h3><p>SQL LIKE子句中使用百分号（%）字符来表示任意字符，类似于UNIX或者正则表达式中的星号（*）。</p>
<h4 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h4><pre><code class="mysql">SELECT field1, field2, ...fieldN
FROM table_name1, table_name2...
WHERE field1 LIKE condition [[AND][OR]] field2=&#39;somevalue&#39;
</code></pre>
<p>注：</p>
<p>·你可以在WHERE子句中指定任何条件</p>
<p>·你可以在WHERE字句中使用LIKE子句</p>
<p>·你可以使用LIKE子句代替等号</p>
<p>·LIKE通常与%一同使用，类似于一个元字符的搜索</p>
<p>·你可以使用AND或OR指定一个或多个条件</p>
<p>·你可以在DELETE或UPDATE命令中使用WHERE…LIKE子句来指定条件</p>
<p>举例：查询w3cschool_tbl表中的w3cschool_author字段中以’jay’为结尾的所有记录：</p>
<pre><code class="mysql">SELECT * from w3cschool_tbl
WHERE w3cschool_author LIKE &#39;%jay&#39;;
</code></pre>
<h3 id="MySQL排序"><a href="#MySQL排序" class="headerlink" title="MySQL排序"></a>MySQL排序</h3><h4 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h4><pre><code class="mysql">SELECT field1, field2,...fieldN FROM table_name1, table_name2...
ORDER BY field1, [field2...] [ASC[DESC]]
</code></pre>
<p>注：</p>
<p>·你可以使用任何字段来作为排序的条件，从而返回排序后的查询结果</p>
<p>·你可以设定多个字段来排序</p>
<p>·你可以使用ASC或DESC关键字来设置查询结果是按升序或者降序排列。默认情况下，它是按升序排列</p>
<p>·你可以添加WHERE…LIKE子句来设置条件</p>
<p>举例：使用ORDER BY子句来读取MySQL数据表w3cschool_tbl中的数据：</p>
<p><code>SELECT * from w3cschool_tbl ORDER BY w3cschool_author ASC;</code></p>
<p><code>SELECT * from w3cschool_tbl ORDER BY w3cschool_author DESC;</code></p>
<h3 id="MySQL-分组"><a href="#MySQL-分组" class="headerlink" title="MySQL 分组"></a>MySQL 分组</h3><p>GROUP BY语句根据一个或者多个列对结果集进行分组，在分组的列上我们可以使用COUNT,SUM,AVG等函数。</p>
<h4 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h4><pre><code class="mysql">SELECT column_name, function(column_name)
FROM table_name
WHERE column_name operator value
GROUP BY column_name;
</code></pre>
<p>employee_tbl表格信息如下：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th>name</th>
<th>date</th>
<th>singin</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td>小明</td>
<td>2016-04-22 15:25:33</td>
<td>1</td>
</tr>
<tr>
<td align="center">2</td>
<td>小王</td>
<td>2016-04-20 15:25:47</td>
<td>3</td>
</tr>
<tr>
<td align="center">3</td>
<td>小丽</td>
<td>2016-04-19 15:26:02</td>
<td>2</td>
</tr>
<tr>
<td align="center">4</td>
<td>小王</td>
<td>2016-04-07 15:26:14</td>
<td>4</td>
</tr>
<tr>
<td align="center">5</td>
<td>小明</td>
<td>2016-04-11 15:26:40</td>
<td>4</td>
</tr>
<tr>
<td align="center">6</td>
<td>小明</td>
<td>2016-04-04 15:26:54</td>
<td>2</td>
</tr>
</tbody></table>
<p>举例：将数据表按名字进行分组，并统计每个人有多少条记录：</p>
<p><code>SELECT name, COUNT(*) FROM employ_tbl GROUP BY name;</code></p>
<h3 id="使用WITH-ROLLUP"><a href="#使用WITH-ROLLUP" class="headerlink" title="使用WITH ROLLUP"></a>使用WITH ROLLUP</h3><p>WITH ROLLUP可以实现在分组统计数据基础上再进行相同的统计（SUM.AVG,COUNT).</p>
<p>举例：将以上的数据表按名字进行分组，再统计每个人登录的次数：</p>
<pre><code class="mysql">SELECT name, SUM(singin) as singin_count
FROM employee_tbl
GROUP BY name WITH ROLLUP;
</code></pre>
<p>其中结果如下：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>singin_out</th>
</tr>
</thead>
<tbody><tr>
<td>小丽</td>
<td>2</td>
</tr>
<tr>
<td>小明</td>
<td>7</td>
</tr>
<tr>
<td>小王</td>
<td>7</td>
</tr>
<tr>
<td>NULL</td>
<td>16</td>
</tr>
</tbody></table>
<p>其中记录NULL表示所有人的登录次数，我们可以使用coalesce来设置一个可以取代NULL的名称。</p>
<h4 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h4><p><code>select coalesce(a, b, c);</code></p>
<p>参数说明：如果a&#x3D;&#x3D;null,则选择b;如果b&#x3D;&#x3D;null,则选择c;如果a!&#x3D;null,则选择a;如果abc都为null,则返回null(没意义)。</p>
<p>举例：如果名字为空，使用总数代替：</p>
<pre><code class="mysql">SELECT coalesce(name, &#39;总数&#39;), SUM(singin) as singin_out
FROM employee_tbl
GROUP BY name WITH ROLLUP;
</code></pre>
<h3 id="MySQL连接的使用"><a href="#MySQL连接的使用" class="headerlink" title="MySQL连接的使用"></a>MySQL连接的使用</h3><p>JOIN按照功能大致分为如下三类：</p>
<p>·INNER JOIN(内连接，或等值连接)：获取两个表中字段匹配关系的记录</p>
<p>·LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录</p>
<p>·RIGHT JOIN(右连接)：用于获取右表所有记录，即使左表没有对应匹配的记录</p>
<p><a href="https://raw.githubusercontent.com/pistachio0812/pistachio0812.github.io/main/images/SQL_JOINS.png">SQL JOINS</a></p>
<p>假设W3CSCHOOL数据库中有两张表tcount_tbl和w3cschool_tbl,两张数据表数据如下：</p>
<p>1.tcount_tbl</p>
<table>
<thead>
<tr>
<th align="center">w3cschool_author</th>
<th>w3cschool_count</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mahran</td>
<td>20</td>
</tr>
<tr>
<td align="center">mahnaz</td>
<td>NULL</td>
</tr>
<tr>
<td align="center">Jen</td>
<td>NULL</td>
</tr>
<tr>
<td align="center">Gill</td>
<td>20</td>
</tr>
<tr>
<td align="center">John Poul</td>
<td>1</td>
</tr>
<tr>
<td align="center">Sanjay</td>
<td>1</td>
</tr>
</tbody></table>
<p>2.w3cschool_tbl</p>
<table>
<thead>
<tr>
<th>w3cschool_id</th>
<th>w3cschool_title</th>
<th>w3cschool_author</th>
<th>submission_date</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Learn PHP</td>
<td>John Poul</td>
<td>2007-05-24</td>
</tr>
<tr>
<td>2</td>
<td>Learn MyQL</td>
<td>Abdul S</td>
<td>2007-05-24</td>
</tr>
<tr>
<td>3</td>
<td>JAVA Tutorial</td>
<td>Sanjay</td>
<td>2007-05-06</td>
</tr>
</tbody></table>
<p>举例：使用INNER JOIN来连接以上两张表来读取w3cschool_tbl表中所有w3cschool_author字段在tcount_tbl表中对应的w3cschool_count字段值。</p>
<pre><code class="mysql">SELECT a.w3cschool_id, a.w3cschool_author, b.w3cschool_count
FROM w3cschool_tbl a INNER JOIN tcount_tbl b
ON a.w3cschool_author = b.w3cschool_author
</code></pre>
<p>等价于：</p>
<pre><code class="mysql">SELECT a.w3cschool_id, a_w3cschool_author, b.w3cschool_count
FROM w3cschool_tbl a, tcount_tbl b
WHERE a.w3cschool_author = b.w3cschool_author;
</code></pre>
<p>举例：以w3cschool_tbl为左表， t_count_tbl为右表，理解MySQL LEFT JOIN的应用：</p>
<pre><code class="mysql">SELECT a.w3cschool_id, a.w3cschool_author, b.w3cschool_count
FROM w3cschool_tbl a LEFT JOIN tcount_tbl b
ON a.w3cschool_author = b.w3cschool_author;
</code></pre>
<p>举例：以tcount_tbl为左表， w3cschool_tbl为右表，理解MySQL RIGHT JOIN的应用：</p>
<pre><code class="mysql">SELECT b.w3cschool_id, b.w3cschool_author, a.w3cschool_count
FROM tcount_tbl a RIGHT JOIN w3cschool_tbl b
ON a.w3cschool_author = b.w3cschool_author;
</code></pre>
<h3 id="MySQL-NULL值处理"><a href="#MySQL-NULL值处理" class="headerlink" title="MySQL NULL值处理"></a>MySQL NULL值处理</h3><p>查询条件字段为NULL时，该命令可能无法正常工作，为了处理这种情况，MySQL提供了三大运算符：</p>
<p>·IS NULL:当列的值为NULL,此运算符返回True</p>
<p>·IS NOT NULL:当列的值不为NULL,运算符返回True</p>
<p>·&lt;&#x3D;&gt;:比较运算符，当比较的两个值为NULL时返回True</p>
<p>关于NULL的条件比较运算是比较特殊的，你不能够使用&#x3D;NULL或！&#x3D;NULL在列中查找NULL值，在MySQL中，NULL值与任何其他值的比较永远返回false,即NULL&#x3D;NULL返回false。</p>
<h4 id="在命令提示符中使用NULL值"><a href="#在命令提示符中使用NULL值" class="headerlink" title="在命令提示符中使用NULL值"></a>在命令提示符中使用NULL值</h4><p>假设数据库W3CSCHOOL中的表tcount_tbl含有两列w3cschool_author和w3cschool_count, w3cschool_count中设置插入NULL值。</p>
<p>假设表如下所示：</p>
<table>
<thead>
<tr>
<th>w3cschool_author</th>
<th>w3cschool_count</th>
</tr>
</thead>
<tbody><tr>
<td>mahran</td>
<td>20</td>
</tr>
<tr>
<td>mahnaz</td>
<td>NULL</td>
</tr>
<tr>
<td>Jen</td>
<td>NULL</td>
</tr>
<tr>
<td>Gill</td>
<td>20</td>
</tr>
</tbody></table>
<p>查询数据表中w3cschool_count列是否为NULL,必须使用IS NULL和IS NOT NULL,如下实例：</p>
<pre><code class="mysql">SELECT * FROM tcount_tbl
WHERE w3cschool_count IS NULL;
</code></pre>
<pre><code class="mysql">SELECT * FROM tcount_tbl
WHERE w3cschool_count IS NOT NULL;
</code></pre>
<h3 id="MySQL正则表达式"><a href="#MySQL正则表达式" class="headerlink" title="MySQL正则表达式"></a>MySQL正则表达式</h3><p>下表中的正则模式可应用于REGEXP操作符中。</p>
<table>
<thead>
<tr>
<th>^</th>
<th>匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配’\n’或’\r’之后的位置。</th>
</tr>
</thead>
<tbody><tr>
<td>$</td>
<td>匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，^也匹配’\n’或’\r’之前的位置。</td>
</tr>
<tr>
<td>.</td>
<td>匹配除’\n’之外的任何单个字符。要匹配包括’\n’在内的任何字符，请使用’[.\n]’的模式。</td>
</tr>
<tr>
<td>[…]</td>
<td>字符集合。匹配所包含的任何一个字符。例如’[abc]’可以匹配’plain’中的’a’。</td>
</tr>
<tr>
<td>[^…]</td>
<td>负值字符集合。匹配未包含的任意字符。例如，’[^abc]’可以匹配’plain’中的’p’。</td>
</tr>
<tr>
<td>p1|p2|p3</td>
<td>匹配p1或p2或p3.例如，’z|food’能匹配’z’或’food’。，’(z|f)food’能匹配’zood’或’food’</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次。例如，zo能匹配’z’以及’zoo’.*等价于{0，}。</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次。例如，’zo+’能匹配’zo’以及’zoo’,但不能匹配’z’。+等价于{1，}</td>
</tr>
<tr>
<td>{n}</td>
<td>n是一个非负整数。匹配确定的n次。例如，’o{2}’不能匹配’Bob’中的’o’,但是能匹配’food’中的两个o。</td>
</tr>
<tr>
<td>{n, m}</td>
<td>m和n均为非负整数，其中n&lt;&#x3D;m。最少匹配n次且最多匹配m次。</td>
</tr>
</tbody></table>
<p>举例：</p>
<p>1.查找name字段中以’st’为开头的所有数据：</p>
<pre><code class="mysql">SELECT name FROM person_tbl WHERE name REGEXP &#39;^st&#39;;
</code></pre>
<p>2.查找name字段中以’ok’为结尾的所有数据：</p>
<pre><code class="mysql">SELECT name FROM person_tbl WHERE name REGEXP &#39;ok$&#39;;
</code></pre>
<p>3.查找name字段中包含’mar’字符串的所有数据：</p>
<pre><code class="mysql">SELECT name FROM person_tbl WHERE name REGEXP &#39;mar&#39;
</code></pre>
<p>4.查找name字段中以元音字符开头或以’ok’字符串结尾的所有数据：</p>
<pre><code class="mysql">SELECT name FROM person_tbl WHERE name REGEXP &#39;^[aeiou]|ok$&#39;
</code></pre>
<h3 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h3><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p>
<ul>
<li>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</li>
<li>事务处理可以用来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行。</li>
<li>事务用来管理 insert , update , delete 语句。</li>
</ul>
<p>一般来说，事务是必须满足4个条件（ACID）： Atomicity（原子性或不可分割性）、Consistency（一致性）、Isolation（隔离性或独立性）、Durability（持久性）</p>
<ul>
<li>1、<strong>原子性：</strong>一组事务，要么成功；要么撤回，即事务在执行过程中出错会回滚到事务开始前的状态。</li>
<li>2、<strong>一致性</strong> ： 一个事务不论是开始前还是结束后，数据库的完整性都没有被破坏。因此写入的数据必须完全符合所有预设规则（资料精确度、串联性以及后续数据库能够自发完成预定工作）。</li>
<li>3、<strong>隔离性：</strong>数据库允许多个事务并发的同时对其数据进行读写修改等操作，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离可分为：Read uncommitted（读未提交）、Read committed（读提交）、Repeatable read（可重复读）、Serializable（串行化）。</li>
<li>4、持久<strong>性：</strong>事务在处理结束后对数据做出的修改是永久的，无法丢失</li>
</ul>
<h4 id="事务控制语句"><a href="#事务控制语句" class="headerlink" title="事务控制语句"></a>事务控制语句</h4><p>1.显式的开始一个事务：</p>
<p><code>start transaction</code>或者<code>begin</code></p>
<p>2.做保存点，一个事务中可以有多个保存点：</p>
<p><code>savepoint  [savepoint_name]</code></p>
<p>3.提交事务，并使数据库中进行的修改成为永久性的：</p>
<p><code>commit</code>或<code>commit work</code></p>
<p>4.回滚结束用户的事务，并撤销正在进行的所有未提交的修改：</p>
<p><code>rollback</code>或<code>rollback work</code></p>
<p>5.删除一个事务的保存点，若没有指定保存点，执行该语句操作则会抛错：</p>
<p><code>release savepoint [savepoint_name]</code></p>
<p>6.将事务滚回标记点：</p>
<p><code>rollback to 标记点</code></p>
<p>7.设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。</p>
<pre><code>set transaction
</code></pre>
<h4 id="事务处理方法"><a href="#事务处理方法" class="headerlink" title="事务处理方法"></a>事务处理方法</h4><p>1.用 begin ， rollback ， commit 来实现事务处理。</p>
<p>2.用 set 来改变 MySQL 的自动提交模式。</p>
<ul>
<li>set autocommit &#x3D; 0 （禁止自动提交）。</li>
<li>set autocommit &#x3D; 1 （开启自动提交）。</li>
</ul>
<h3 id="MySQL-ALTER命令"><a href="#MySQL-ALTER命令" class="headerlink" title="MySQL ALTER命令"></a>MySQL ALTER命令</h3><p>当我们需要修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令。</p>
<p>开始本章教程前让我们先创建一张表，表名为：testalter_tbl。</p>
<pre><code class="mysql">create table testalter_tbl(
    i INT,
    c CHAR(1)
    );
 
</code></pre>
<p><code>SHOW COLUMNS FROM testalter_tbl;</code></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Null</th>
<th>Key</th>
<th>Default</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>int(11)</td>
<td>YES</td>
<td></td>
<td>NULL</td>
<td></td>
</tr>
<tr>
<td>c</td>
<td>char(1)</td>
<td>YES</td>
<td></td>
<td>NULL</td>
<td></td>
</tr>
</tbody></table>
<h4 id="删除、添加或修改表字段"><a href="#删除、添加或修改表字段" class="headerlink" title="删除、添加或修改表字段"></a>删除、添加或修改表字段</h4><p><em>如下命令使用了 ALTER 命令及 DROP 子句来删除以上创建表的 i 字段：</em></p>
<p><em><code>mysql&gt; ALTER TABLE testalter_tbl  DROP i; </code></em></p>
<p><em>如果数据表中只剩余一个字段则无法使用DROP来删除字段。</em></p>
<p><em>MySQL 中使用 ADD 子句来想数据表中添加列，如下实例在表 testalter_tbl 中添加 i 字段，并定义数据类型:</em></p>
<p><code>mysql&gt; ALTER TABLE testalter_tbl ADD i INT; </code></p>
<p>执行以上命令后，i 字段会自动添加到数据表字段的末尾。</p>
<p>&#96;mysql&gt; SHOW COLUMNS FROM testalter_tbl; </p>
<p> <code>+-------+---------+------+-----+---------+-------+ </code></p>
<p> <code>| Field | Type    | Null | Key | Default | Extra | </code></p>
<p> <code>+-------+---------+------+-----+---------+-------+ </code></p>
<p> <code>| c     | char(1) | YES  |     | NULL    |       |</code></p>
<p> <code> | i     | int(11) | YES  |     | NULL    |       |</code> </p>
<p> <code>+-------+---------+------+-----+---------+-------+</code> </p>
<p> <code>2 rows in set (0.00 sec) </code></p>
<p>如果你需要指定新增字段的位置，可以使用MySQL提供的关键字 FIRST (设定位第一列)， AFTER 字段名（设定位于某个字段之后）。</p>
<p>尝试以下 ALTER TABLE 语句, 在执行成功后，使用 SHOW COLUMNS 查看表结构的变化：</p>
<p><code>ALTER TABLE testalter_tbl DROP i; </code></p>
<p> <code>ALTER TABLE testalter_tbl ADD i INT FIRST;</code></p>
<p> <code> ALTER TABLE testalter_tbl DROP i;</code> </p>
<p> <code>ALTER TABLE testalter_tbl ADD i INT AFTER c;</code></p>
<p>FIRST 和 AFTER 关键字只占用于 ADD 子句，所以如果你想重置数据表字段的位置就需要先使用 DROP 删除字段然后使用 ADD 来添加字段并设置位置。</p>
<h4 id="修改字段类型及名称"><a href="#修改字段类型及名称" class="headerlink" title="修改字段类型及名称"></a>修改字段类型及名称</h4><p>如果需要修改字段类型及名称, 你可以在ALTER命令中使用 MODIFY 或 CHANGE 子句 。</p>
<p>例如，把字段 c 的类型从 CHAR(1) 改为 CHAR(10)，可以执行以下命令:</p>
<p><code>mysql&gt; ALTER TABLE testalter_tbl MODIFY c CHAR(10);</code></p>
<p> 使用 CHANGE 子句, 语法有很大的不同。 在 CHANGE 关键字之后，紧跟着的是你要修改的字段名，然后指定新字段的类型及名称。尝试如下实例：</p>
<p><code>mysql&gt; ALTER TABLE testalter_tbl CHANGE i j BIGINT; </code></p>
<p>如果你现在想把字段 j 从 BIGINT 修改为 INT，SQL语句如下：</p>
<p><code>mysql&gt; ALTER TABLE testalter_tbl CHANGE j j INT; </code></p>
<h4 id="ALTER-TABLE-对-Null-值和默认值的影响"><a href="#ALTER-TABLE-对-Null-值和默认值的影响" class="headerlink" title="ALTER TABLE 对 Null 值和默认值的影响"></a>ALTER TABLE 对 Null 值和默认值的影响</h4><p>当你修改字段时，你可以指定是否包含只或者是否设置默认值。以下实例，指定字段 j 为 NOT NULL 且默认值为100 。</p>
<p><code>mysql&gt; ALTER TABLE testalter_tbl </code></p>
<p>​        <code>-&gt; MODIFY j BIGINT NOT NULL DEFAULT 100; </code></p>
<p>如果你不设置默认值，MySQL会自动设置该字段默认为 NULL。</p>
<h4 id="修改字段默认值"><a href="#修改字段默认值" class="headerlink" title="修改字段默认值"></a>修改字段默认值</h4><p>你可以使用 ALTER 来修改字段的默认值，尝试以下实例：</p>
<p><code>mysql&gt; ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000; </code></p>
<p><code>mysql&gt; SHOW COLUMNS FROM testalter_tbl; </code></p>
<p> <code>+-------+---------+------+-----+---------+-------+ </code></p>
<p> <code>| Field | Type    | Null | Key | Default | Extra |</code></p>
<p> <code>+-------+---------+------+-----+---------+-------+</code> </p>
<p> <code>| c     | char(1) | YES  |     | NULL    |       | </code></p>
<p> <code>| i     | int(11) | YES  |     | 1000    |       | </code></p>
<p> <code>+-------+---------+------+-----+---------+-------+ </code></p>
<p> <code>2 rows in set (0.00 sec)</code></p>
<p>你也可以使用 ALTER 命令及 DROP子句来删除字段的默认值，如下实例：</p>
<p><code>mysql&gt; ALTER TABLE testalter_tbl ALTER i DROP DEFAULT; </code></p>
<p> <code>mysql&gt; SHOW COLUMNS FROM testalter_tbl; </code></p>
<p> <code>+-------+---------+------+-----+---------+-------+ </code></p>
<p> <code>| Field | Type    | Null | Key | Default | Extra |</code></p>
<p> <code>+-------+---------+------+-----+---------+-------+</code> </p>
<p> <code>| c     | char(1) | YES  |     | NULL    |       | </code></p>
<p> <code>| i     | int(11) | YES  |     | NULL    |       | </code></p>
<p> <code>+-------+---------+------+-----+---------+-------+ </code></p>
<p> <code>2 rows in set (0.00 sec) Changing a Table Type: </code></p>
<p>修改数据表类型，可以使用 ALTER 命令及 TYPE 子句来完成。尝试以下实例，我们将表 testalter_tbl 的类型修改为 MYISAM ：<strong>注意：</strong>查看数据表类型可以使用 SHOW TABLE STATUS 语句。*</p>
<pre><code>mysql&gt; ALTER TABLE testalter_tbl TYPE = MYISAM;
mysql&gt;  SHOW TABLE STATUS LIKE &#39;testalter_tbl&#39;\G
 1. row **
           Name: testalter_tbl
           Type: MyISAM
     Row_format: Fixed
           Rows: 0
 Avg_row_length: 0
    Data_length: 0
Max_data_length: 25769803775
   Index_length: 1024
      Data_free: 0
 Auto_increment: NULL
    Create_time: 2007-06-03 08:04:36
    Update_time: 2007-06-03 08:04:36
     Check_time: NULL
 Create_options:
        Comment:
1 row in set (0.00 sec)
</code></pre>
<h4 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h4><p>如果需要修改数据表的名称，可以在 ALTER TABLE 语句中使用 RENAME 子句来实现。</p>
<p>尝试以下实例将数据表 testalter_tbl 重命名为 alter_tbl：</p>
<pre><code>mysql&gt; ALTER TABLE testalter_tbl RENAME TO alter_tbl;
</code></pre>
<h3 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h3><p>MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。</p>
<p>打个比方，如果合理的设计且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。</p>
<p>拿汉语字典的目录页（索引）打比方，我们可以按拼音、笔画、偏旁部首等排序的目录（索引）快速查找到需要的字。</p>
<p>索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。</p>
<p>创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。</p>
<p>实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。</p>
<p>上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。</p>
<p>建立索引会占用磁盘空间的索引文件。</p>
<h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><p>创建索引</p>
<p>这是最基本的索引，它没有任何限制。它有以下几种创建方式：</p>
<pre><code>CREATE INDEX indexName ON mytable(username(length)); 
</code></pre>
<p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p>
<p>修改表结构(添加索引)</p>
<pre><code>ALTER table tableName ADD INDEX indexName(columnName)
</code></pre>
<p>创建表的时候直接指定</p>
<pre><code>CREATE TABLE mytable(  
 
ID INT NOT NULL,   
 
username VARCHAR(16) NOT NULL,  
 
INDEX [indexName] (username(length))  
 
);  
</code></pre>
<p>删除索引的语法</p>
<pre><code>DROP INDEX [indexName] ON mytable; 
</code></pre>
<h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：</p>
<p>创建索引</p>
<pre><code>CREATE UNIQUE INDEX indexName ON mytable(username(length)) 
</code></pre>
<p>修改表结构</p>
<pre><code>ALTER table mytable ADD UNIQUE [indexName] (username(length))
</code></pre>
<p>创建表的时候直接指定</p>
<pre><code>CREATE TABLE mytable(  
 
ID INT NOT NULL,   
 
username VARCHAR(16) NOT NULL,  
 
UNIQUE [indexName] (username(length))  
 
);  
</code></pre>
<p>使用ALTER 命令添加和删除索引</p>
<p>有四种方式来添加数据表的索引：</p>
<ul>
<li>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</li>
<li>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</li>
<li>ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次。</li>
<li>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):该语句指定了索引为 FULLTEXT ，用于全文索引。</li>
</ul>
<p>以下实例为在表中添加索引。</p>
<pre><code>mysql&gt; ALTER TABLE testalter_tbl ADD INDEX (c);
</code></pre>
<p>你还可以在 ALTER 命令中使用 DROP 子句来删除索引。尝试以下实例删除索引:</p>
<pre><code>mysql&gt; ALTER TABLE testalter_tbl DROP INDEX c;
</code></pre>
<p>使用 ALTER 命令添加和删除主键</p>
<p>主键只能作用于一个列上，添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。实例如下：</p>
<pre><code>mysql&gt; ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;
mysql&gt; ALTER TABLE testalter_tbl ADD PRIMARY KEY (i);
</code></pre>
<p>你也可以使用 ALTER 命令删除主键：</p>
<pre><code>mysql&gt; ALTER TABLE testalter_tbl DROP PRIMARY KEY;
</code></pre>
<p>删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。</p>
<p>显示索引信息</p>
<p>你可以使用 SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 \G 来格式化输出信息。</p>
<p>尝试以下实例:</p>
<pre><code>mysql&gt; SHOW INDEX FROM table_name; \G
........
</code></pre>
<h3 id="MySQL临时表"><a href="#MySQL临时表" class="headerlink" title="MySQL临时表"></a>MySQL临时表</h3><p>MySQL 临时表在我们需要保存一些临时数据时是非常有用的。临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。</p>
<p>临时表在MySQL 3.23版本中添加，如果你的MySQL版本低于 3.23版本就无法使用MySQL的临时表。不过现在一般很少有再使用这么低版本的MySQL数据库服务了。</p>
<p>MySQL临时表只在当前连接可见，如果你使用PHP脚本来创建MySQL临时表，那每当PHP脚本执行完成后，该临时表也会自动销毁。</p>
<p>如果你使用了其他MySQL客户端程序连接MySQL数据库服务器来创建临时表，那么只有在关闭客户端程序时才会销毁临时表，当然你也可以手动销毁。</p>
<p>实例</p>
<p>以下展示了使用MySQL 临时表的简单实例，以下的SQL代码可以适用于PHP脚本的mysql_query()函数。</p>
<pre><code class="mysql">mysql&gt; CREATE TEMPORARY TABLE SalesSummary (
    -&gt; product_name VARCHAR(50) NOT NULL
    -&gt; , total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00
    -&gt; , avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00
    -&gt; , total_units_sold INT UNSIGNED NOT NULL DEFAULT 0
);
Query OK, 0 rows affected (0.00 sec)

mysql&gt; INSERT INTO SalesSummary
    -&gt; (product_name, total_sales, avg_unit_price, total_units_sold)
    -&gt; VALUES
    -&gt; (&#39;cucumber&#39;, 100.25, 90, 2);

mysql&gt; SELECT * FROM SalesSummary;
+--------------+-------------+----------------+------------------+
| product_name | total_sales | avg_unit_price | total_units_sold |
+--------------+-------------+----------------+------------------+
| cucumber     |      100.25 |          90.00 |                2 |
+--------------+-------------+----------------+------------------+
1 row in set (0.00 sec)
</code></pre>
<p>当你使用 <strong>SHOW TABLES</strong>命令显示数据表列表时，你将无法看到 SalesSummary表。</p>
<p>如果你退出当前MySQL会话，再使用 <strong>SELECT</strong>命令来读取原先创建的临时表数据，那你会发现数据库中没有该表的存在，因为在你退出时该临时表已经被销毁了。</p>
<p>删除MySQL 临时表</p>
<p>默认情况下，当你断开与数据库的连接后，临时表就会自动被销毁。当然你也可以在当前MySQL会话使用 <strong>DROP TABLE</strong> 命令来手动删除临时表。</p>
<p>以下是手动删除临时表的实例：</p>
<pre><code class="mysql">mysql&gt; CREATE TEMPORARY TABLE SalesSummary (
    -&gt; product_name VARCHAR(50) NOT NULL
    -&gt; , total_sales DECIMAL(12,2) NOT NULL DEFAULT 0.00
    -&gt; , avg_unit_price DECIMAL(7,2) NOT NULL DEFAULT 0.00
    -&gt; , total_units_sold INT UNSIGNED NOT NULL DEFAULT 0
);
Query OK, 0 rows affected (0.00 sec)

mysql&gt; INSERT INTO SalesSummary
    -&gt; (product_name, total_sales, avg_unit_price, total_units_sold)
    -&gt; VALUES
    -&gt; (&#39;cucumber&#39;, 100.25, 90, 2);

mysql&gt; SELECT * FROM SalesSummary;
+--------------+-------------+----------------+------------------+
| product_name | total_sales | avg_unit_price | total_units_sold |
+--------------+-------------+----------------+------------------+
| cucumber     |      100.25 |          90.00 |                2 |
+--------------+-------------+----------------+------------------+
1 row in set (0.00 sec)
mysql&gt; DROP TABLE SalesSummary;
mysql&gt;  SELECT * FROM SalesSummary;
ERROR 1146: Table &#39;W3CSCHOOL.SalesSummary&#39; doesn&#39;t exist
</code></pre>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/03/11/CN/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>学术搜索网站集合</title>
    <url>/2022/03/15/CN/%E5%AD%A6%E6%9C%AF%E6%90%9C%E7%B4%A2%E7%BD%91%E7%AB%99%E5%AF%BC%E8%88%AA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>搞学术研究的必不可少的就是论文，而且是大量的论文。因此，在这里我特意把我平时用到的积累到的论文搜索网站集中到了这里，后续遇到了其他的还会继续补充。</p>
<h2 id="谷歌学术"><a href="#谷歌学术" class="headerlink" title="谷歌学术"></a>谷歌学术</h2><p><a href="https://xs.scqylaw.com/">谷歌学术</a>是一个可以免费搜索学术文章的Google网络应用。2004年11月，Google第一次发布了Google学术搜索的试用版。该项索引包括了世界上绝大部分出版的学术期刊， 可广泛搜索学术文献的简便方法。您可以从一个位置搜索众多学科和资料来源：来自学术著作出版商、专业性社团、预印本、各大学及其他学术组织的经同行评论的文章、论文、图书、摘要和文章。Google 学术搜索可帮助您在整个学术领域中确定相关性最强的研究。</p>
<p>相关页面如下：</p>
<p><img src="https://img.99lb.net/images1/logo.png" class="lazyload" data-srcset="https://img.99lb.net/images1/logo.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="谷歌学术搜索"></p>
<h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><p><a href="https://github.com/">github</a>于2008年4月10日正式上线，除了代码仓库托管及基本的Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目Ruby on Rails、jQuery、python等。</p>
<p>相关页面如下：</p>
<p><img src="https://pic2.zhimg.com/v2-3224a8e2da3f76575baaa77e5768fcb2_1440w.jpg?source=172ae18b" class="lazyload" data-srcset="https://pic2.zhimg.com/v2-3224a8e2da3f76575baaa77e5768fcb2_1440w.jpg?source=172ae18b" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="github"></p>
<h2 id="CVPR"><a href="#CVPR" class="headerlink" title="CVPR"></a>CVPR</h2><p>国际计算机视觉与模式识别会议（<a href="http://www.cvpapers.com/">CVPR</a>）是IEEE一年一度的学术性会议，会议的主要内容是计算机视觉与模式识别技术。CVPR是世界顶级的计算机视觉会议（三大顶会之一，另外两个是ICCV和ECCV，近年来每年有约1500名参加者，收录的论文数量一般300篇左右。本会议每年都会有固定的研讨主题，而每一年都会有公司赞助该会议并获得在会场展示的机会。</p>
<p>相关页面如下：</p>
<p><img src="http://www.cvpapers.com/img/cvpapers.png" class="lazyload" data-srcset="http://www.cvpapers.com/img/cvpapers.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="CVPR"></p>
<h2 id="CVF"><a href="#CVF" class="headerlink" title="CVF"></a>CVF</h2><p><a href="https://openaccess.thecvf.com/">CVF</a>研究论文是由计算机视觉基金会提供的开放获取版本。除水印外，它们与接受的版本相同;最后发表的论文集可以在IEEE Xplore上找到。本材料的提出，以确保及时传播学术和技术工作。版权和其中的所有权利由作者或其他版权持有人保留。所有复制此信息的人都应遵守每个作者的版权所援引的条款和约束。</p>
<h2 id="arXiv"><a href="#arXiv" class="headerlink" title="arXiv"></a>arXiv</h2><p><a href="https://arxiv.org/">arXiv</a>是一个免费分发服务和开放获取的档案，涵盖物理、数学、计算机科学、定量生物学、定量金融学、统计学、电气工程和系统科学以及经济学领域的2,040,232篇学术文章。</p>
<h2 id="paperswithcode"><a href="#paperswithcode" class="headerlink" title="paperswithcode"></a>paperswithcode</h2><p><a href="https://paperswithcode.com/">Papers With Code</a>代码论文的任务是创建一个免费和开放的资源与机器学习论文，代码，数据集，方法和评估表。我们相信，在NLP和ML的支持下，与社区合作是最好的。这个网站上的所有内容都是公开许可的CC-BY-SA(与维基百科一样)，每个人都可以贡献——寻找“编辑”按钮!我们还运营专门的门户网站，提供天文学、物理学、计算机科学、数学和统计学的论文代码。</p>
]]></content>
  </entry>
  <entry>
    <title>详解注意力机制</title>
    <url>/2022/03/31/CN/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h3><p>注意力机制就是让网络关注到它更需要关注的地方，是一种网络自适应注意的方式。注意力机制可以分为通道注意力，空间注意力以及二者的结合。</p>
<h3 id="相关论文"><a href="#相关论文" class="headerlink" title="相关论文"></a>相关论文</h3><p>1.<a href="https://openaccess.thecvf.com/content_cvpr_2018/papers/Hu_Squeeze-and-Excitation_Networks_CVPR_2018_paper.pdf">SENet</a></p>
<p>2017年提出的SENet是最后一届ImageNet竞赛的冠军，其实现示意图如下所示，对于输入进来的特征层，我们关注其每一个通道的权重，对于SENet而言，其重点是获得输入进来的特征层，每一个通道的权值。利用SENet，我们可以让网络关注它最需要关注的通道。</p>
<p>其具体实现方式就是：<br>1、对输入进来的特征层进行全局平均池化。<br>2、然后进行两次全连接，第一次全连接神经元个数较少，第二次全连接神经元个数和输入特征层相同。<br>3、在完成两次全连接后，我们再取一次Sigmoid将值固定到0-1之间，此时我们获得了输入特征层每一个通道的权值（0-1之间）。<br>4、在获得这个权值后，我们将这个权值乘上原输入特征层即可。<br><img src="/2022/03/31/CN/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/image-20220331191026838.png" class="lazyload" data-srcset="/2022/03/31/CN/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/image-20220331191026838.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<pre><code class="python">import torch
import torch.nn as nn
import math

class se_block(nn.Module):
    def __init__(self, channel, ratio=16):
        super(se_block, self).__init__()
        self.avg_pool = nn.AdaptiveAvgPool2d(1)
        self.fc = nn.Sequential(
                nn.Linear(channel, channel // ratio, bias=False),
                nn.ReLU(inplace=True),
                nn.Linear(channel // ratio, channel, bias=False),
                nn.Sigmoid()
        )

    def forward(self, x):
        b, c, _, _ = x.size()
        y = self.avg_pool(x).view(b, c)
        y = self.fc(y).view(b, c, 1, 1)
        return x * y
</code></pre>
<p>2.<a href="https://openaccess.thecvf.com/content_ECCV_2018/papers/Sanghyun_Woo_Convolutional_Block_Attention_ECCV_2018_paper.pdf">CBAM</a></p>
<p>CBAM将<strong>通道注意力机制和空间注意力机制</strong>进行一个结合，相比于<strong>SENet只关注通道的注意力机制</strong>可以取得更好的效果。其实现示意图如下所示，CBAM会对输入进来的特征层，分别进行<strong>通道注意力机制的处理和空间注意力机制的处理</strong>。</p>
<img src="/2022/03/31/CN/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/image-20220331155344988.png" class="lazyload" data-srcset="/2022/03/31/CN/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/image-20220331155344988.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>下图是通道注意力机制和空间注意力机制的具体实现方式：<br>图像的上半部分为通道注意力机制，通道注意力机制的实现可以分为两个部分，我们会对输入进来的单个特征层，分别进行全局平均池化和全局最大池化。之后对平均池化和最大池化的结果，利用共享的全连接层进行处理，我们会对处理后的两个结果进行相加，然后取一个sigmoid，此时我们获得了输入特征层每一个通道的权值（0-1之间）。在获得这个权值后，我们将这个权值乘上原输入特征层即可。</p>
<p>图像的下半部分为空间注意力机制，我们会对输入进来的特征层，在每一个特征点的通道上取最大值和平均值。之后将这两个结果进行一个堆叠，利用一次通道数为1的卷积调整通道数，然后取一个sigmoid，此时我们获得了输入特征层每一个特征点的权值（0-1之间）。在获得这个权值后，我们将这个权值乘上原输入特征层即可。</p>
<img src="/2022/03/31/CN/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/image-20220331155451951.png" class="lazyload" data-srcset="/2022/03/31/CN/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/image-20220331155451951.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<pre><code class="python">class ChannelAttention(nn.Module):
    def __init__(self, in_planes, ratio=8):
        super(ChannelAttention, self).__init__()
        self.avg_pool = nn.AdaptiveAvgPool2d(1)
        self.max_pool = nn.AdaptiveMaxPool2d(1)

        # 利用1x1卷积代替全连接
        self.fc1   = nn.Conv2d(in_planes, in_planes // ratio, 1, bias=False)
        self.relu1 = nn.ReLU()
        self.fc2   = nn.Conv2d(in_planes // ratio, in_planes, 1, bias=False)

        self.sigmoid = nn.Sigmoid()

    def forward(self, x):
        avg_out = self.fc2(self.relu1(self.fc1(self.avg_pool(x))))
        max_out = self.fc2(self.relu1(self.fc1(self.max_pool(x))))
        out = avg_out + max_out
        return self.sigmoid(out)

class SpatialAttention(nn.Module):
    def __init__(self, kernel_size=7):
        super(SpatialAttention, self).__init__()

        assert kernel_size in (3, 7), &#39;kernel size must be 3 or 7&#39;
        padding = 3 if kernel_size == 7 else 1
        self.conv1 = nn.Conv2d(2, 1, kernel_size, padding=padding, bias=False)
        self.sigmoid = nn.Sigmoid()

    def forward(self, x):
        avg_out = torch.mean(x, dim=1, keepdim=True)
        max_out, _ = torch.max(x, dim=1, keepdim=True)
        x = torch.cat([avg_out, max_out], dim=1)
        x = self.conv1(x)
        return self.sigmoid(x)

class cbam_block(nn.Module):
    def __init__(self, channel, ratio=8, kernel_size=7):
        super(cbam_block, self).__init__()
        self.channelattention = ChannelAttention(channel, ratio=ratio)
        self.spatialattention = SpatialAttention(kernel_size=kernel_size)

    def forward(self, x):
        x = x * self.channelattention(x)
        x = x * self.spatialattention(x)
        return x
</code></pre>
<p>3.<a href="https://sci-hub.mksa.top/10.1109/cvpr42600.2020.01155">ECANet</a></p>
<p>ECANet是也是通道注意力机制的一种实现形式。ECANet可以看作是SENet的改进版。<br>ECANet的作者认为SENet对通道注意力机制的预测带来了副作用，捕获所有通道的依赖关系是低效并且是不必要的。<br>在ECANet的论文中，作者认为卷积具有良好的跨通道信息获取能力。</p>
<p>ECA模块的思想是非常简单的，它去除了原来SE模块中的全连接层，直接在全局平均池化之后的特征上通过一个1D卷积进行学习。</p>
<p>既然使用到了1D卷积，那么1D卷积的卷积核大小的选择就变得非常重要了，了解过卷积原理的同学很快就可以明白，1D卷积的卷积核大小会影响注意力机制每个权重的计算要考虑的通道数量。用更专业的名词就是跨通道交互的覆盖率。</p>
<p>如下图所示，左图是常规的SE模块，右图是ECA模块。ECA模块用1D卷积替换两次全连接。<br><img src="/2022/03/31/CN/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/image-20220331160018390.png" class="lazyload" data-srcset="/2022/03/31/CN/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/image-20220331160018390.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<pre><code class="python">class eca_block(nn.Module):
    def __init__(self, channel, b=1, gamma=2):
        super(eca_block, self).__init__()
        kernel_size = int(abs((math.log(channel, 2) + b) / gamma))
        kernel_size = kernel_size if kernel_size % 2 else kernel_size + 1
        
        self.avg_pool = nn.AdaptiveAvgPool2d(1)
        self.conv = nn.Conv1d(1, 1, kernel_size=kernel_size, padding=(kernel_size - 1) // 2, bias=False) 
        self.sigmoid = nn.Sigmoid()

    def forward(self, x):
        y = self.avg_pool(x)
        y = self.conv(y.squeeze(-1).transpose(-1, -2)).transpose(-1, -2).unsqueeze(-1)
        y = self.sigmoid(y)
        return x * y.expand_as(x)
</code></pre>
<h3 id="注意力机制的应用"><a href="#注意力机制的应用" class="headerlink" title="注意力机制的应用"></a>注意力机制的应用</h3><p>注意力机制是一个即插即用的模块，理论上可以放在任何一个特征层后面，可以放在主干网络，也可以放在加强特征提取网络。</p>
<p>由于放置在主干会导致网络的预训练权重无法使用，本文以YoloV4-tiny为例，将注意力机制应用加强特征提取网络上。</p>
<p>如下图所示，我们在主干网络提取出来的两个有效特征层上增加了注意力机制，同时对上采样后的结果增加了注意力机制。<br><img src="/2022/03/31/CN/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/image-20220331160207149.png" class="lazyload" data-srcset="/2022/03/31/CN/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/image-20220331160207149.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<pre><code class="python">attention_block = [se_block, cbam_block, eca_block]

#---------------------------------------------------#
#   特征层-&gt;最后的输出
#---------------------------------------------------#
class YoloBody(nn.Module):
    def __init__(self, anchors_mask, num_classes, phi=0):
        super(YoloBody, self).__init__()
        self.phi            = phi
        self.backbone       = darknet53_tiny(None)

        self.conv_for_P5    = BasicConv(512,256,1)
        self.yolo_headP5    = yolo_head([512, len(anchors_mask[0]) * (5 + num_classes)],256)

        self.upsample       = Upsample(256,128)
        self.yolo_headP4    = yolo_head([256, len(anchors_mask[1]) * (5 + num_classes)],384)

        if 1 &lt;= self.phi and self.phi &lt;= 3:
            self.feat1_att      = attention_block[self.phi - 1](256)
            self.feat2_att      = attention_block[self.phi - 1](512)
            self.upsample_att   = attention_block[self.phi - 1](128)

    def forward(self, x):
        #---------------------------------------------------#
        #   生成CSPdarknet53_tiny的主干模型
        #   feat1的shape为26,26,256
        #   feat2的shape为13,13,512
        #---------------------------------------------------#
        feat1, feat2 = self.backbone(x)
        if 1 &lt;= self.phi and self.phi &lt;= 3:
            feat1 = self.feat1_att(feat1)
            feat2 = self.feat2_att(feat2)

        # 13,13,512 -&gt; 13,13,256
        P5 = self.conv_for_P5(feat2)
        # 13,13,256 -&gt; 13,13,512 -&gt; 13,13,255
        out0 = self.yolo_headP5(P5) 

        # 13,13,256 -&gt; 13,13,128 -&gt; 26,26,128
        P5_Upsample = self.upsample(P5)
        # 26,26,256 + 26,26,128 -&gt; 26,26,384
        if 1 &lt;= self.phi and self.phi &lt;= 3:
            P5_Upsample = self.upsample_att(P5_Upsample)
        P4 = torch.cat([P5_Upsample,feat1],axis=1)

        # 26,26,384 -&gt; 26,26,256 -&gt; 26,26,255
        out1 = self.yolo_headP4(P4)
        
        return out0, out1
# 研究方向为CV的可以关注Bubbliiiing,也可以顺道关注一下博主心系五道口，谢谢！！！
————————————————
版权声明：本文为CSDN博主「Bubbliiiing」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_44791964/article/details/121371986
</code></pre>
]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>Attention</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉单词</title>
    <url>/2022/03/12/CN/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%8D%95%E8%AF%8D%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code>                                       计算机视觉单词表
</code></pre>
<p>artificial neural network,ANN        人工神经网络</p>
<p>perceptron        感知机，人工神经元</p>
<p>activation function        激活函数</p>
<p>rectified linear unit,RELU        修正线性单元</p>
<p>bias        偏置</p>
<p>loss function        损失函数</p>
<p>universal approximation theorem        万能逼近定理</p>
<p>one-hot encoding        独热编码</p>
<p>cross-entropy        交叉熵</p>
<p>dropout        丢弃</p>
<p>bagging        装袋</p>
<p>model averaging        模型平均</p>
<p>batch normalization        批归一化</p>
<p>backpropagation        反向传播</p>
<p>stochastic gradient descent,SGD        随机梯度下降</p>
<p>acquisition         学习，获得</p>
<p>integrate       整合，集成，合并</p>
<p>diverse         多样化的，不同的</p>
<p>tune          调优</p>
<p>curation        内容管理</p>
<p>projection      投影，预测</p>
<p>coherent         有条理的，连贯的</p>
<p>redundant        冗余的</p>
<p>entity          实体</p>
<p>synthetic     合成的，虚假的，不诚恳的</p>
<p>spammy     垃圾邮件式的，无聊的</p>
<p>crowdsourcing          众包</p>
<p>continuity        连续性，连贯性</p>
<p>manifold       多种多样的</p>
<p>inherent        固有的，内在的</p>
<p>pseudo     假的，仿冒的</p>
<p>ensemble         套</p>
<p>heuristic        启发式的；启发式教育法</p>
<p>erroneous        错误的，不正确的</p>
<p>resilient        有弹性的，可迅速恢复的</p>
<p>degraded        堕落的，退化的</p>
<p>converge        收敛，集中</p>
<p>outlier        离群值，异常值</p>
<p>violate        违反，违背</p>
<p>syntactic        语法的</p>
<p>cartesian        笛卡尔的</p>
<p>categorical        分类，绝对的</p>
<p>prune        修剪</p>
<p>param        停止</p>
<p>translation  invariance        平移不变性</p>
<p>suppress        抑制，镇压，阻止</p>
<p>bidirectional        双向</p>
<p>tabular        扁平的，列成表格的</p>
<p>revenue        收入，税收</p>
<p>latency        延迟</p>
<p>harmonic        和声的，谐和的，音乐般的</p>
<p>harmonic mean        调和平均数</p>
<p>harmonic series        调和级数</p>
<p>rote        死记硬背，生搬硬套</p>
<p>bid        出价，投标</p>
<p>leaderboard        排行榜，通栏广告</p>
<p>minor        较小的，次要的，轻微的</p>
<p>contaminated        受污染的，弄脏的</p>
<p>tradeoff        权衡，折中</p>
<p>ensemble learning        集成学习</p>
<p>decompose        分解，使腐烂</p>
<p>intrinsic        内在的，固有的</p>
<p>notable         显要的，值得注意的；非常成功的，令人尊敬的</p>
<p>camouflaged        伪装的</p>
<p>facilitate        促进，使便利</p>
<p>overlap    与……重叠，部分地相同；重叠的部分，互搭量</p>
<p>threshold    入口，门槛，开始，极限，临界值</p>
<p>conjecture    猜测，推测</p>
<p>within    在……之内</p>
<p>oversample:过采样</p>
<p>trade off:权衡，卖掉，折中方案</p>
<p>ultimately:最后，根本，基本上</p>
<p>robotics：机器人学</p>
<p>areial:空中的，航空的，空气的</p>
<p>underperform:表现不佳，工作不如预期</p>
<p>crucial:重要的，决定性的</p>
<p>high-resolution:高分辨率的</p>
<p>deploy:配置，展开，部署</p>
<p>barely:仅仅，勉强，几乎不</p>
<p>tumor:肿瘤，肿块</p>
<p>diagnosis:诊断</p>
<p>inspection:检查，视察</p>
<p>defect:缺陷，缺点，不足之处</p>
<p>annotate:注释，作注解</p>
<p>address:地址，编址</p>
<p>potentially:可能地，潜在地</p>
<p>imply:意味，暗示，隐含</p>
<p>diversity:多样性，差异</p>
<p>generalize:概括，推广，使……一般化</p>
<p>portion:部分</p>
<p>crop:裁剪</p>
<p>merge:合并</p>
<p>align:匹配，排列，对齐，对准</p>
<p>mask:掩码，掩膜</p>
<p>cascade:小瀑布，串联，级联</p>
<p>fuse:融合，熔接，熔化</p>
<p>computational:计算的</p>
<p>overhead:经常性费用，运营费用</p>
<p>fraction:分数，部分，小部分，稍微</p>
<p>schematic illustration:示意图</p>
<p>respect to:关于，考虑</p>
<p>validate:验证，确认，使生效</p>
<p>stochastic:随机的，猜测的</p>
<p>decay    衰退，衰减</p>
<p>coefficient    系数，率</p>
<p>explicitly    明确地，明白地</p>
<p>outline    大纲，概要</p>
<p>distillation:蒸馏</p>
<p>curvature:曲率</p>
<p>stochastic    随机</p>
<p>variance    差异，方差</p>
<p>spectrum    光谱，频谱；范围</p>
<p>neat    灵巧的，整洁的；优雅的，平滑的</p>
<p>heterogenerous    由很多种类组成的</p>
<p>intricate    复杂的，错综的</p>
<p>arbitrary    任意的，武断的</p>
<p>vanilla    香草，比较原始的</p>
<p>sketch    示意图</p>
<p>incarnation    化身，典型</p>
<p>waive    放弃，搁置</p>
<p>shrinkage    收缩，皱缩，缩水; 跌价; 抽缩</p>
<p>alleviate    缓解，减轻</p>
<p>de-facto    事实上</p>
<p>corpus    文集，语料库</p>
<p>unprecedented    前所未有的</p>
<p>inductive    归纳的</p>
<p>empirical    经验主义的</p>
<p>allergic    过敏的，反感的</p>
<p>pollen     花粉</p>
<p>badminton    羽毛球运动</p>
<p>pharmacy    药房</p>
<p>jasmine    茉莉</p>
<p>latent    潜在的，潜伏的，潜意识的</p>
<p>prepend    预先考虑</p>
<p>embedding    编码</p>
<p>alternating    交互的</p>
<p>interpolation    插入，篡改，添写</p>
<p>de-duplicate    删除重复数据</p>
<p>suite    一套，套件</p>
<p>geometric    几何图形的，几何的</p>
<p>intermediate    中间的</p>
<p>fine-tuning    微调</p>
<p>appendix    附录</p>
<p>warmup    预热</p>
<p>least-squares regression    最小二乘回归</p>
<p>on-the-fly    匆匆忙忙地；在空中；（计）运行中</p>
<p>literature    文献</p>
<p>outperform    胜过，做的比……好</p>
<p>substantially    实质上；大体上；充分地</p>
<p>standard deviation    标准差</p>
<p>co-training    协同训练</p>
<p>boost    促进，增加</p>
<p>overtake    赶上，压倒，突然来袭</p>
<p>plateau    趋于平稳，进入停滞期</p>
<p>vanish    消失</p>
<p>versus     与</p>
<p>saturate    饱和的</p>
<p>principal    最主要的</p>
<p>plausible    貌似可信的，花言巧语的；貌似真实的，貌似有理的</p>
<p>sinusoidal    正弦曲线的</p>
<p>degree    程度</p>
<p>analogous    类似的</p>
<p>preliminary    初步的</p>
<p>manual    手动的，手工的</p>
<p>insight    洞察力，领悟</p>
<p>exponentially    以指数方式的</p>
<p>holistically    整体论地</p>
<p>unidirectional    单向性的</p>
<p>incorporate    包含，吸收，体现；把……合并</p>
<p>alleviate    减轻</p>
<p>shallow    浅的，肤浅的</p>
<p>discriminate    区分，辨别</p>
<p>coarser    粗糙的</p>
<p>granularity    间隔尺寸，粒度</p>
<p>derived    导出的，衍生的，派生的</p>
<p>predecessor    前任，前辈;(被取代的)原有事物，前身</p>
<p>cloze    adj. 完形的；填充测验法的</p>
<p>cloze task    完形填空</p>
<p>recipe    秘诀，处方</p>
<p>distinctive    有特色的，与众不同的</p>
<p>unambiguously    不含糊地，明白地</p>
<p>intuitively    直观地；直觉地</p>
<p>trivially    琐细地，平凡地，无能地</p>
<p>mitigate    使缓和，使减轻</p>
<p>monolingual    单语的；仅用一种语言的；仅懂一种语言的</p>
<p>procedure    程序，手续，步骤</p>
<p>degenerate    使退化，恶化</p>
<p>de-facto    (法)实际上的</p>
<p>explicitly    显式地</p>
<p>reformulate    重新构造</p>
<p>ensemble    全体，总效果</p>
<p>nontrivial    重要的，显著的</p>
<p>obstacle    阻碍，障碍</p>
<p>notorious    臭名昭著的，声名狼藉的</p>
<p>vanishing&#x2F;exploding gradients    梯度消失&#x2F;梯度爆炸</p>
<p>hamper    妨碍，束缚</p>
<p>degradation    退化，降级，堕落</p>
<p>thoroughly    完全地，彻底地</p>
<p>counterpart    副本，配对物</p>
<p>feasible    可行的，可能的</p>
<p>akin to     类似于</p>
<p>generic    类的，属性的; 一般的; 不受商标保护的; [生]属的，类的</p>
<p>retrieval    检索</p>
<p>quantization    量化</p>
<p>partial differential equations    偏微分方程</p>
<p>auxiliary    辅助的，备用的</p>
<p>Concurrent    并发的，同时发生的</p>
<p>asymptotically    渐近地</p>
<p>counterintuitive    违反直觉的</p>
<p>perturbations    [流]扰动，不安</p>
<p>trial    测试</p>
<p>curse    咒骂，诅咒</p>
<p>estimation    评估，评价，判断</p>
<p>surrogate    代理的</p>
<p>prominent    突出的，显著的，卓越的，杰出的</p>
<p>thes    命题，论文</p>
<p>recalibrate    重新校准</p>
<p>pruning    剪枝</p>
<p>proxy    代理人，代表权</p>
<p>compound    加重; 使复杂化; 混合;混合的</p>
<p>criteria    标准，条件</p>
<p>panoptic    全景的</p>
<p>controversial    有争议的</p>
<p>problematic    有疑问的，有问题的</p>
<p>contrastive    对比的</p>
<p>intuitive    直觉的; 凭直觉获知的; 直观的</p>
<p>preserve    保存；保护；维持；腌；禁猎</p>
<p>intractable    棘手的；难治的；倔强的；不听话的</p>
<p>pretext    借口，托辞; 假象，掩饰</p>
<p>permutation    排列，置换</p>
<p>discrimination    区别对待; 鉴别力; 区别</p>
<p>shuffle    洗牌; 曳脚而行; 搬移; 搁置，随手放</p>
<p>neatness    整洁，干净</p>
<p>blur    模糊</p>
<p>permutation    排列，置换</p>
<p>infrared    红外线的</p>
<p>attenuation    衰减，衰变</p>
<p>tricky    棘手的，难对付的</p>
<p>plethora    过多，过剩</p>
<p>deluge    泛滥，淹没</p>
<p>elaborate    精心制作的，详尽的</p>
<p>repurpose    改换意图，重新</p>
<p>assistive    辅助性的</p>
<p>eliminate    消除</p>
<p>duplicate    重复的</p>
<p>coordinate    坐标</p>
<p>refreshingly    清爽地，有精神地，令人耳目一新地</p>
<p>millisecond     毫秒</p>
<p>implicitly    隐式地</p>
<p>delimiter    分隔符</p>
<p>diverge    分歧，相异</p>
<p>remedy    解决方法，纠正方法</p>
<p>deviation    偏差</p>
<p>coarse    粗糙的</p>
<p>begnign    无有害的，认为无关紧要的</p>
<p>malicious    恶意的，怀恨的</p>
<p>rigorous    严格的</p>
<p>outlier    离群值</p>
<p>deliberate    故意的；深思熟虑的；从容的</p>
<p>susceptible    易受影响的；易感动的；容许…的</p>
<p>leverage    利用</p>
<p>kinda    有点，有几分</p>
<p>centroid    形心，重心</p>
<p>exclusively    专门地，唯一地</p>
<p>collision    碰撞，警告</p>
<p>hint    暗示，示意</p>
<p>stand-alone    （计算机）独立运行的；（公司、组织）独立的</p>
<p>photometric distortion    光度失真</p>
<p>geometric    几何失真</p>
<p>hue    色调</p>
<p>saturation    饱和度</p>
<p>superimpose    叠加</p>
<p>adjacent    相邻的</p>
<p>incorporate    包含，吸收；体现；把……合并</p>
<p>mimic    模仿</p>
<p>tentative    初步的</p>
<p>tackle    处理</p>
<p>cortex    皮层</p>
<p>factorization    因子分解，因式分解</p>
<p>compatible    兼容的</p>
<p>substantially    实质上；大体上；充分地</p>
<p>explicitly    明确地；明白地</p>
<p>reformulate    v. 再制订；换种方式说（或表达）</p>
<p>nontrival    重要的</p>
<p>notorious    声名狼藉的，臭名昭著的</p>
<p>aggregated    聚合的，合计的</p>
<p>cardinality    基数</p>
<p>acquisition    获得物</p>
<p>obscured    遮挡</p>
<p>out-of-view    看不见的</p>
<p>precedent    先前的</p>
<p>intuitive    直观的</p>
<p>overhead    开销</p>
<p>efficacy    功效，效力</p>
<p>hierarchical    分层的</p>
<p>foeval    视网膜中心的</p>
<p>iteratively    迭代地</p>
<p>salient    重点的</p>
<p>modality    形式，形态</p>
<p>in a conditional fashion    有条件的方式</p>
<p>squeeze    挤压</p>
<p>excitation    激励</p>
<p>self-contained    独立的，设备齐全的，沉默寡言的</p>
<p>aggregate    集合，聚集</p>
<p>superscript    上标</p>
<p>an apples to apples comparison    比较两个相近的事物</p>
<p>thoroughly    彻底地，完全地</p>
<p>conjecture    推测，猜测</p>
<p>auxiliary    辅助的</p>
<p>parentheses    圆括号，插入成分</p>
<p>nest    嵌套</p>
<p>the best of both worlds    两全其美</p>
<p>incur    带来（成本、花费）等；招致，遭受</p>
<p>decimal    十进位的，小数的</p>
<p>timestamp    时间戳</p>
<p>clause    从句，分句；（法律文件的）条款</p>
<p>overlap    重叠</p>
<p>coalesce    合并，联合</p>
<p>rollup    归纳，卷曲，袅袅上升</p>
<p>coarse-to-fine    由粗到细，由繁到简</p>
<p>tic-tac-toe    井字棋，圈叉游戏</p>
<p>overlay    覆在……上面，覆盖</p>
<p>cached    贮藏起来，高速缓存</p>
<p>eigen    特征，固有的</p>
<p>tremendous    巨大的，极好的</p>
<p>versus    （比赛或诉讼中）以……为对手，与……竞争；与……相对，与……相比</p>
<p>delineating    描述，描绘</p>
<p>primitive    原始的</p>
<p>recalibrating    重新调整</p>
<p>magenta    洋红色</p>
<p>cyan    青绿色</p>
<p>pentagon    五边形</p>
<p>hexagon    六边形</p>
<p>diamond    菱形</p>
<p>line chart    折线图</p>
<p>flip    翻转</p>
<p>alias    别名</p>
<p>incurring    招致，遭受</p>
<p>ellipse    椭圆</p>
<p>tile    平铺，瓷砖</p>
<p>diversity    多样性</p>
<p>discard    丢弃</p>
<p>adequately    充分地，足够地</p>
]]></content>
  </entry>
  <entry>
    <title>How to use Linux</title>
    <url>/2022/03/24/en/Linux%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h3><p>UNIX 是一个交互式系统，用于同时处理多进程和多用户同时在线。为什么要说 UNIX，那是因为 Linux 是由 UNIX 发展而来的，UNIX 是由程序员设计，它的主要服务对象也是程序员。Linux 继承了 UNIX 的设计目标。从智能手机到汽车，超级计算机和家用电器，从家用台式机到企业服务器，Linux 操作系统无处不在。</p>
<p>大多数程序员都喜欢让系统尽量简单，优雅并具有一致性。举个例子，从最底层的角度来讲，一个文件应该只是一个字节集合。为了实现顺序存取、随机存取、按键存取、远程存取只能是妨碍你的工作。相同的，如果命令</p>
<p>ls A*<br>意味着只列出以 A 为开头的所有文件，那么命令</p>
<p>rm A*<br>应该会移除所有以 A 为开头的文件而不是只删除文件名是 A* 的文件。这个特性也是最小吃惊原则(principle of least surprise)</p>
<p>最小吃惊原则一般常用于用户界面和软件设计。它的原型是：该功能或者特征应该符合用户的预期，不应该使用户感到惊讶和震惊。</p>
<p>一些有经验的程序员通常希望系统具有较强的功能性和灵活性。设计 Linux 的一个基本目标是每个应用程序只做一件事情并把他做好。所以编译器只负责编译的工作，编译器不会产生列表，因为有其他应用比编译器做的更好。</p>
<p>很多人都不喜欢冗余，为什么在 cp 就能描述清楚你想干什么时候还使用 copy？这完全是在浪费宝贵的 hacking time。为了从文件中提取所有包含字符串 ard 的行，Linux 程序员应该输入</p>
<p>grep ard f</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Liunx system</tag>
      </tags>
  </entry>
  <entry>
    <title>github使用指南</title>
    <url>/2022/03/25/en/github%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h4><p>1.安装git OSX版</p>
<p>下载地址：<a href="http://git-scm.com/download/mac">http://git-scm.com/download/mac</a></p>
<p>2.安装git Windows版</p>
<p>下载地址：<a href="http://book.git-scm.com/download/win">http://book.git-scm.com/download/win</a></p>
<p>3.安装git Linux版</p>
<p>下载地址：<a href="http://book.git-scm.com/download/linux">http://book.git-scm.com/download/linux</a></p>
<h4 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h4><p>创建新文件夹，打开，然后执行<code>git init</code>以创建新的git仓库</p>
<h4 id="检出仓库"><a href="#检出仓库" class="headerlink" title="检出仓库"></a>检出仓库</h4><p>执行如下命令以创建一个本地仓库的克隆版本：</p>
<p><code>git clone /path/to/repository</code></p>
<p>如果是远端服务器上的仓库，则使用如下命令：</p>
<p><code>git clone username@host:/path/to/repository</code></p>
<h4 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h4><p>你的本地仓库由git维护的三棵“树”组成。第一个是你的<strong>工作目录</strong>，它持有实际文件；第二个是<strong>暂存区（index)</strong>,它像个缓存区域，临时保存你的改动；最后是<strong>HEAD</strong>,它指向你最后一次提交的结果。</p>
<h4 id="添加和提交"><a href="#添加和提交" class="headerlink" title="添加和提交"></a>添加和提交</h4><p>你可以提出更改（把它们添加到暂存区），使用如下命令：</p>
<p><code>git add &lt;filename&gt;</code></p>
<p><code>git add *</code></p>
<p>这是git基本工作流程的第一步；使用如下命令以实际提交改动：</p>
<p><code>git commit -m &quot;代码提交信息&quot;</code></p>
<p>现在，你的改动已经提交到了HEAD,但是还没到你的远端仓库。</p>
<h4 id="推送改动"><a href="#推送改动" class="headerlink" title="推送改动"></a>推送改动</h4><p>你的改动现在已经在本地仓库的HEAD中了。执行如下命令以将这些改动提交到远端仓库：</p>
<p><code>git push origin master</code></p>
<p>可以把<em>master</em>换成你想要推送的任何分支。</p>
<p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：</p>
<p><code>git remote add origin &lt;server&gt;</code></p>
<p>如此你就能够将你的改动推送到所添加的服务器上去了。</p>
<h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，<em>master</em>是默认的分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p>
<p>创建一个叫做“feature_x”的分支，并切换过去：</p>
<p><code>git checkout -b feature_x</code></p>
<p>切换回主分支：</p>
<p><code>git checkout master</code></p>
<p>再把新建的分支删掉：</p>
<p><code>git branch -d feature_x</code></p>
<p>除非你将分支推送到远端仓库，不然该分支就是不为他人所见的：</p>
<p><code>git push origin &lt;branch&gt;</code></p>
<h4 id="更新与合并"><a href="#更新与合并" class="headerlink" title="更新与合并"></a>更新与合并</h4><p>要更新你的本地仓库至最新改动，执行：<br><code>git pull</code><br>以在你的工作目录中 <em>获取（fetch）</em> 并 <em>合并（merge）</em> 远端的改动。<br>要合并其他分支到你的当前分支（例如 master），执行：<br><code>git merge &lt;branch&gt;</code><br>在这两种情况下，git 都会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现<em>冲突（conflicts）</em>。 这时候就需要你修改这些文件来手动合并这些<em>冲突（conflicts）</em>。改完之后，你需要执行如下命令以将它们标记为合并成功：</p>
<p><code>git add &lt;filename&gt;</code><br>在合并改动之前，你可以使用如下命令预览差异：<br><code>git diff &lt;source_branch&gt; &lt;target_branch&gt;</code></p>
<h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>为软件发布创建标签是推荐的。这个概念早已存在，在 SVN 中也有。你可以执行如下命令创建一个叫做 <em>1.0.0</em> 的标签：<br><code>git tag 1.0.0 1b2e1d63ff</code><br><em>1b2e1d63ff</em> 是你想要标记的提交 ID 的前 10 位字符。可以使用下列命令获取提交 ID：<br><code>git log</code><br>你也可以使用少一点的提交 ID 前几位，只要它的指向具有唯一性。</p>
<h4 id="log"><a href="#log" class="headerlink" title="log"></a>log</h4><p>如果你想了解本地仓库的历史记录，最简单的命令就是使用:<br><code>git log</code><br>你可以添加一些参数来修改他的输出，从而得到自己想要的结果。 只看某一个人的提交记录:<br><code>git log --author=bob</code><br>一个压缩后的每一条提交记录只占一行的输出:<br><code>git log --pretty=oneline</code><br>或者你想通过 ASCII 艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签:<br><code>git log --graph --oneline --decorate --all</code><br>看看哪些文件改变了:<br><code>git log --name-status</code><br>这些只是你可以使用的参数中很小的一部分。更多的信息，参考：<br><code>git log --help</code></p>
<h4 id="替换本地改动"><a href="#替换本地改动" class="headerlink" title="替换本地改动"></a>替换本地改动</h4><p>假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动：<br><code>git checkout -- &lt;filename&gt;</code><br>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。</p>
<p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：<br><code>git fetch origin</code><br><code>git reset --hard origin/master</code></p>
<h4 id="实用小贴士"><a href="#实用小贴士" class="headerlink" title="实用小贴士"></a>实用小贴士</h4><p>内建的图形化 git：<br><code>gitk</code><br>彩色的 git 输出：<br><code>git config color.ui true</code><br>显示历史记录时，每个提交的信息只显示一行：<br><code>git config format.pretty oneline</code><br>交互式添加文件到暂存区：<br><code>git add -i</code></p>
<p>更多内容请参考：<a href="http://rogerdudler.github.io/git-guide/index.zh.html">git - 简明指南</a></p>
]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>使用指南</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>pip换源</title>
    <url>/2022/04/01/en/pip%E6%8D%A2%E6%BA%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于使用pip或pip3安装python第三方包时，经常出现read timed out问题，所以需要将pip的官方软件源服务器换成国内的镜像服务器，从而提升python软件包安装效率和成功率，pip 国内的一些镜像：</p>
<ul>
<li>阿里云 <a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a></li>
<li>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a></li>
<li>豆瓣(douban) <a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a></li>
<li>清华大学 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a></li>
<li>中国科学技术大学 <a href="http://pypi.mirrors.ustc.edu.cn/simple/">http://pypi.mirrors.ustc.edu.cn/simple/</a></li>
</ul>
<h2 id="更换源"><a href="#更换源" class="headerlink" title="更换源"></a>更换源</h2><h3 id="临时使用"><a href="#临时使用" class="headerlink" title="临时使用"></a>临时使用</h3><p>可以在使用 pip 的时候在后面加上-i 参数，指定 pip 源</p>
<pre><code>eg: pip install scrapy -i https://pypi.tuna.tsinghua.edu.cn/simple
</code></pre>
<h3 id="永久修改"><a href="#永久修改" class="headerlink" title="永久修改"></a>永久修改</h3><h4 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h4><p>修改 ~&#x2F;.pip&#x2F;pip.conf (没有就创建一个文件夹及文件，文件夹要加“.”，表示是隐藏文件夹)， 内容如下：</p>
<pre><code class="python">[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple
[install]
trusted-host = https://pypi.tuna.tsinghua.edu.cn
</code></pre>
<h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><p>1.pip永久换源</p>
<pre><code class="python">pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/
</code></pre>
<p>在cmd命令行中输入上述命令即可。</p>
<p>最后，升级 pip 到最新的版本</p>
<pre><code class="python">pip install pip -U
</code></pre>
<pre><code class="python">python -m pip install --user --upgrade pip
</code></pre>
<p>2.直接在 user 目录中创建一个 pip 目录，如：C:\Users\xx\pip，在 pip 目录下新建文件 pip.ini，即 %HOMEPATH%\pip\pip.ini，内容如下：</p>
<pre><code>[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple
[install]
trusted-host = pypi.tuna.tsinghua.edu.cn
</code></pre>
<p>可以在开始运行里面输入三个点 <code>...</code>，敲回车即可打开用户目录。</p>
]]></content>
  </entry>
  <entry>
    <title>Q &amp; A</title>
    <url>/2022/03/17/CN/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="就地操作"><a href="#就地操作" class="headerlink" title="就地操作"></a>就地操作</h3><p>问题来源：看代码发现<code>self.relu=nn.ReLU(inplace=True)</code>不明白<code>inplace=True</code>什么意思。</p>
<p>解答：查看pytorch官网关于ReLU定义，<a href="https://pytorch.org/docs/stable/generated/torch.nn.ReLU.html#torch.nn.ReLU">ReLU</a>其中inplace参数表示可以选择就地执行操作，默认为False,就地执行操作是指图像处理函数的输入图像和输出图像是同一对象，即同一张图像，常规的图像处理函数是不支持输入图像和输出图像是同一图像的。</p>
<p>eg:中值滤波函数</p>
<p><code>medianBlur(src, dst, 7);  //常规操作</code></p>
<p><code>medianBlur(src,  src, 7); //就地操作</code></p>
<p>就地操作直接更改张量的内容，而无需复制它。由于它不创建输入的副本，因此在处理高维数据时减少了内存使用，就地操作有助于使用更少的GPU内存，详情请看该博客<a href="https://www.ksgszhuce.com/tetl/37.html">如何在Pytorch中执行就地操作</a></p>
<h3 id="torch-max中keepdim的作用"><a href="#torch-max中keepdim的作用" class="headerlink" title="torch.max中keepdim的作用"></a>torch.max中keepdim的作用</h3><p>torch.max的用法：</p>
<p>(max, max_indices) &#x3D; torch.max(input, dim, keepdim&#x3D;False)</p>
<ul>
<li>输入：</li>
</ul>
<ol>
<li>input 是输入的tensor。</li>
<li>dim 是索引的维度，dim&#x3D;0寻找每一列的最大值，dim&#x3D;1寻找每一行的最大值。</li>
<li>keepdim 表示是否需要保持输出的维度与输入一样，keepdim&#x3D;True表示输出和输入的维度一样，keepdim&#x3D;False表示输出的维度被压缩了，也就是输出会比输入低一个维度。</li>
</ol>
<ul>
<li>输出：</li>
</ul>
<ol>
<li><p>max 表示取最大值后的结果。</p>
</li>
<li><p>2max_indices 表示最大值的索引</p>
</li>
</ol>
<p><code>import torch</code></p>
<p><code>import numpy as np</code></p>
<p><code>x = torch.randint(0,9,(2,4))</code></p>
<p><code>print(x) tensor([[7, 8, 7, 2],         [6, 0, 3, 0]])</code></p>
<p>#取每一行的最大值，torch.max的输出结果</p>
<p><code>y = torch.max(x, 1)   print(y) torch.return_types.max(values=tensor([8, 6]),indices=tensor([1, 0])) #索引值</code></p>
<p><code>y = torch.max(x, 1, keepdim=True)[0]</code><br><code>print(y)</code><br><code>print(np.shape(y)) # keepdim=True，输出仍然是二维的</code><br><code>tensor([[8],          [6]])torch.Size([2, 1])</code><br><code>y = torch.max(x, 1, keepdim=False)[0]</code><br><code>print(y)</code><br><code>print(np.shape(y)) keepdim=False # 输出变成了一维 </code>tensor([8, 6])<br><code>torch.Size([2])</code></p>
<h3 id="ConstantPad2d的用法"><a href="#ConstantPad2d的用法" class="headerlink" title="ConstantPad2d的用法"></a>ConstantPad2d的用法</h3><p>torch.nn.ConstantPad2d(padding, value)</p>
<p>参数：padding(int, tuple)-padding的尺寸，如果是整型，那么所有的边界都使用相同的填充，如果是四元组，使用（padding_left, padding_right, padding_top, padding_bottom)</p>
<p>形状：</p>
<ul>
<li><p>输入：<br>$$<br>(N, C, H_{in}, W_{in}) or (C, H_{in}, W_{in})<br>$$</p>
</li>
<li><p>输出：<br>$$<br>(N, C, H_{out}, W_{out}) or (C, H_{out}, W_{out})<br>$$<br>其中，<br>$$<br>H_{out} &#x3D; H_{in}+padding_{top}+padding_{bottom}<br>$$</p>
<p>$$<br>W_{out}&#x3D;W_{in}+padding_{left}+padding_{right}<br>$$</p>
</li>
</ul>
<p>测试用例：</p>
<pre><code>import torch
import torch.nn as nn

n1 = nn.ConstantPad2d(2, 0)
n2 = nn.ConstantPad2d((0, 1, 0, 1), 0)
n3 = nn.ConstantPad2d((-1, 0, -1, 0), 0)
input = torch.randn(1, 2, 2)
print(input)
t = n1(input)
print(t)
x = n2(input)
y = n3(x)
print(x)
print(y)
</code></pre>
<p>结果：</p>
<p>tensor([[[ 1.0826,  0.1191],<br>         [-0.3506,  0.1677]]])<br>tensor([[[ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],<br>         [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],<br>         [ 0.0000,  0.0000,  1.0826,  0.1191,  0.0000,  0.0000],<br>         [ 0.0000,  0.0000, -0.3506,  0.1677,  0.0000,  0.0000],<br>         [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],<br>         [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000]]])<br>tensor([[[ 1.0826,  0.1191,  0.0000],<br>         [-0.3506,  0.1677,  0.0000],<br>         [ 0.0000,  0.0000,  0.0000]]])<br>tensor([[[0.1677, 0.0000],<br>         [0.0000, 0.0000]]])</p>
<p>更多详情参考<a href="https://pytorch.org/docs/stable/generated/torch.nn.ConstantPad2d.html?highlight=constantpad2d#torch.nn.ConstantPad2d">ConstantPad2d</a></p>
<h3 id="enumerate-函数"><a href="#enumerate-函数" class="headerlink" title="enumerate()函数"></a>enumerate()函数</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。Python 2.3. 以上版本可用，2.6 添加 start 参数。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>enumerate(sequence, [start=0])</code></p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>·sequence–一个序列、迭代器或其他支持迭代对象</p>
<p>·start–下标起始位置的值</p>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>返回enumerate(枚举)对象</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>以下展示了使用enumerate()方法的实例：</p>
<blockquote>
<p>seasons &#x3D; [‘Spring’, ‘Summer’, ‘Fall’, ‘Winter’]</p>
<p>list(enumerate(seasons))</p>
<p><code>[(0, &#39;Spring&#39;), (1, &#39;Summer&#39;), (2, &#39;Fall&#39;), (3, &#39;Winter&#39;)]</code></p>
<p>list(enumerate(seasons, start&#x3D;1))    # 下标从1开始</p>
<p><code>[(1, &#39;Spring&#39;), (2, &#39;Summer&#39;), (3, &#39;Fall&#39;), (4, &#39;Winter&#39;)]</code></p>
</blockquote>
<p>普通的for循环</p>
<pre><code class="python">i = 0
seq = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]
for i in enumerate(seq):
    print(i, seq[i])
    i += 1

result:
0 one
1 two
2 three
</code></pre>
<p>for循环使用enumerate</p>
<pre><code class="python">seq = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]
for i, element in enumerate(seq):
    print(i, element)

result:
0 one
1 two
2 three
</code></pre>
<h3 id="torch-clamp"><a href="#torch-clamp" class="headerlink" title="torch.clamp"></a>torch.clamp</h3><p><code>torch.clamp(input, min=None, max=None, *, out=None)-&gt;Tensor</code></p>
<p>Clamps中所有输入的元素都在[min, max]范围内，让最小值和最大值分别是min和max，将会返回：<br>$$<br>y_i&#x3D;min(max(x_i,min_value_i),max_value_i)<br>$$<br>如果min为空，就没有下界。或者，如果max为空，没有上界。</p>
<p>注：</p>
<p>如果min大于max,<code>torch.clamp(...,min,max)</code>设置输入的所有元素为max的值。</p>
<p>参数：</p>
<p>·input(Tensor)-输入张量</p>
<p>·min(Number或Tensor,可选)-被限制范围的下界</p>
<p>·max(Number或Tensor,可选)-被限制范围的上界</p>
<p>关键字参数：</p>
<p>out(Tensor, 可选)-输出的张量</p>
<p>举例：</p>
<pre><code class="python">&gt;&gt;&gt;a = torch.randn(4)
&gt;&gt;&gt;a
tensor([-1.7120, 0.1734, -0.0478, -0.0922])
&gt;&gt;&gt;torch.clamp(a, min=-0.5, max=0.5)
tensor([-0.5000, 0.1734, -0.0478, -0.0922])

&gt;&gt;&gt;min = torch.linspace(-1, 1, steps=4)
&gt;&gt;&gt;torch.clamp(a, min=min)
tensor([-1.000, 0.1734, 0.3333, 1.0000])
</code></pre>
<h3 id="FPPI"><a href="#FPPI" class="headerlink" title="FPPI"></a>FPPI</h3><p><a href="https://blog.csdn.net/Bruce_0712/article/details/78462880">(68条消息) Recall&#x2F;Precision&#x2F;FPPI评价方式详解_Bruce_0712的博客-CSDN博客</a></p>
<h3 id="torchvision-ops-box-iou"><a href="#torchvision-ops-box-iou" class="headerlink" title="torchvision.ops.box_iou"></a>torchvision.ops.box_iou</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p><code>torchvision.ops.box_iou(boxes1:torch.Tensor, boxes2:torch.Tensor)-&gt;torch.Tensor</code><a href="https://pytorch.org/vision/stable/_modules/torchvision/ops/boxes.html#box_iou">SOURCE</a></p>
<p>返回两个框的交并比，这两个框的形式都是$$(x_1,y_1,x_2,y_2)$$并且$$0&lt;&#x3D;x_1&lt;x_2,0&lt;&#x3D;y_1&lt;y_2$$</p>
<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><p>·boxes1(Tensor[N, 4])-&gt;第一个框</p>
<p>·boxes2(Tensor[N, 4])-&gt;第二个框</p>
<h4 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h4><p>返回boxes1和boxes2逐元素的配对IOU矩阵（N×M)</p>
<h4 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h4><p>Tensor(N,M)</p>
<h3 id="torch-argmax（）函数"><a href="#torch-argmax（）函数" class="headerlink" title="torch.argmax（）函数"></a>torch.argmax（）函数</h3><p><code>torch.argmax(input)-&gt;LongTensor</code></p>
<p>返回<code>input</code>张量所有元素的最大值序号，这是<code>torch.max()</code>返回的第二个值。</p>
<p>注：</p>
<p>如果这里有多个最大值，则会返回第一个最大值的序号。</p>
<h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><p><code>input(Tensor)-&gt;输入的张量</code></p>
<p>举例：</p>
<pre><code class="python">&gt;&gt;&gt; a = torch.randn(4, 4)
&gt;&gt;&gt; a
tensor([[ 1.3398,  0.2663, -0.2686,  0.2450],
        [-0.7401, -0.8805, -0.3402, -1.1936],
        [ 0.4907, -1.3948, -1.0691, -0.3132],
        [-1.6092,  0.5419, -0.2993,  0.3195]])
&gt;&gt;&gt; torch.argmax(a)
tensor(0)
</code></pre>
<p><code>torch.argmax(input, dim, keppdim=False)-&gt;LongTensor</code></p>
<p>通过指定维度返回张量最大值的序号，这个最大值将会通过<code>torch.max()</code>返回</p>
<h4 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h4><p>·input(Tensor):输入的张量</p>
<p>·dim(int):减少的维度，如果没有，将返回平铺后的张量的argmax.</p>
<p>·keepdim(bool):输出的张量是否保持维度,如果<code>dim=None</code>将忽略。</p>
<p>举例：</p>
<pre><code class="python">&gt;&gt;&gt; a = torch.randn(4, 4)
&gt;&gt;&gt; a
tensor([[ 1.3398,  0.2663, -0.2686,  0.2450],
        [-0.7401, -0.8805, -0.3402, -1.1936],
        [ 0.4907, -1.3948, -1.0691, -0.3132],
        [-1.6092,  0.5419, -0.2993,  0.3195]])
&gt;&gt;&gt; torch.argmax(a, dim=1)
tensor([ 0,  2,  0,  1])
</code></pre>
<pre><code class="python">import torch
a = torch.tensor([
              [
                  [1, 5, 5, 2],
                  [9, -6, 2, 8],
                  [-3, 7, -9, 1]
              ],
 
              [
                  [-1, 7, -5, 2],
                  [9, 6, 2, 8],
                  [3, 7, 9, 1]
              ]])
b = torch.argmax(a, dim=0)
print(b)
print(a.shape)
 
&quot;&quot;&quot;
tensor([[0, 1, 0, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]])
torch.Size([2, 3, 4])&quot;&quot;&quot;
 
# dim=0,即将第一个维度消除，也就是将两个[3*4]矩阵只保留一个，因此要在两组中作比较，即将上下两个[3*4]的矩阵分别在对应的位置上比较大小
 
b = torch.argmax(a, dim=1)
&quot;&quot;&quot;
tensor([[1, 2, 0, 1],
        [1, 2, 2, 1]])
torch.Size([2, 3, 4])
&quot;&quot;&quot;
# dim=1，即将第二个维度消除,这么理解：矩阵维度变为[2*4];
&quot;&quot;&quot;
[1, 5, 5, 2],
[9, -6, 2, 8],
[-3, 7, -9, 1];
纵向压缩成一维，因此变为[1,2,0,1];同理得到[1,2,2,1];
&quot;&quot;&quot;
b = torch.argmax(a,dim=2)
&quot;&quot;&quot;
tensor([[2, 0, 1],
        [1, 0, 2]])
&quot;&quot;&quot;
# dim=2,即将第三个维度消除，这么理解：矩阵维度变为[2*3]
&quot;&quot;&quot;
   [1, 5, 5, 2],
   [9, -6, 2, 8],
   [-3, 7, -9, 1];
横向压缩成一维
[2,0,1],同理得到下面的&quot;&quot;&quot;
</code></pre>
<h3 id="python-call-方法"><a href="#python-call-方法" class="headerlink" title="python _call_()方法"></a>python _<em>call</em>_()方法</h3><p>本节再介绍 <a href="http://c.biancheng.net/python/">Python</a> 类中一个非常特殊的实例方法，即 _<em>call</em>_()。该方法的功能类似于在类中重载 () 运算符，使得类实例对象可以像调用普通函数那样，以“对象名()”的形式使用。</p>
<pre><code class="python"># 引用来自C语言中文网，详情请参考：http://c.biancheng.net/view/2380.html
class CLanguage:
    # 定义__call__方法
    def __call__(self,name,add):
        print(&quot;调用__call__()方法&quot;,name,add)

clangs = CLanguage()
clangs(&quot;C语言中文网&quot;,&quot;http://c.biancheng.net&quot;)
</code></pre>
<p>程序执行结果：</p>
<pre><code>调用__call__()方法 C语言中文网 http://c.biancheng.net
</code></pre>
<p>可以看到，通过在 CLanguage 类中实现 _<em>call</em>_() 方法，使的 clangs 实例对象变为了可调用对象。</p>
<blockquote>
<p>Python 中，凡是可以将 () 直接应用到自身并执行，都称为可调用对象。可调用对象包括自定义的函数、Python 内置函数以及本节所讲的类实例对象。</p>
</blockquote>
<p>对于可调用对象，实际上“名称()”可以理解为是“名称.<strong>call</strong>()”的简写。仍以上面程序中定义的 clangs 实例对象为例，其最后一行代码还可以改写为如下形式：</p>
<pre><code>clangs.__call__(&quot;C语言中文网&quot;,&quot;http://c.biancheng.net&quot;)
</code></pre>
<p>运行程序会发现，其运行结果和之前完全相同。</p>
<p>自定义函数：</p>
<pre><code class="python">def say():
    print(&quot;Python教程：http://c.biancheng.net/python&quot;)
say()
say.__call__()
</code></pre>
<p>程序执行结果：</p>
<pre><code class="python">Python教程：http://c.biancheng.net/python
Python教程：http://c.biancheng.net/python
</code></pre>
<h4 id="用-call-弥补-hasattr-函数的短板"><a href="#用-call-弥补-hasattr-函数的短板" class="headerlink" title="用 call() 弥补 hasattr() 函数的短板"></a>用 <strong>call</strong>() 弥补 hasattr() 函数的短板</h4><p>前面章节介绍了 hasattr() 函数的用法，该函数的功能是查找类的实例对象中是否包含指定名称的属性或者方法，但该函数有一个缺陷，即它无法判断该指定的名称，到底是类属性还是类方法。</p>
<p>要解决这个问题，我们可以借助可调用对象的概念。要知道，类实例对象包含的方法，其实也属于可调用对象，但类属性却不是。举个例子：</p>
<pre><code class="python">class CLanguage:
    def __init__ (self):
        self.name = &quot;C语言中文网&quot;
        self.add = &quot;http://c.biancheng.net&quot;
    def say(self):
        print(&quot;我正在学Python&quot;)

clangs = CLanguage()
if hasattr(clangs,&quot;name&quot;):
    print(hasattr(clangs.name,&quot;__call__&quot;))
print(&quot;**********&quot;)
if hasattr(clangs,&quot;say&quot;):
    print(hasattr(clangs.say,&quot;__call__&quot;))
</code></pre>
<p>程序执行结果：</p>
<pre><code class="python">False
**********
True
</code></pre>
<p>可以看到，由于 name 是类属性，它没有以 <strong>call</strong> 为名的 <strong>call</strong>() 方法；而 say 是类方法，它是可调用对象，因此它有 <strong>call</strong>() 方法。</p>
<h3 id="argparse-函数"><a href="#argparse-函数" class="headerlink" title="argparse()函数"></a>argparse()函数</h3><p><a href="https://docs.python.org/zh-cn/2/library/argparse.html#module-argparse"><code>argparse</code></a> 模块可以让人轻松编写用户友好的命令行接口。程序定义它需要的参数，然后 <a href="https://docs.python.org/zh-cn/2/library/argparse.html#module-argparse"><code>argparse</code></a> 将弄清如何从 <a href="https://docs.python.org/zh-cn/2/library/sys.html#sys.argv"><code>sys.argv</code></a> 解析出那些参数。 <a href="https://docs.python.org/zh-cn/2/library/argparse.html#module-argparse"><code>argparse</code></a> 模块还会自动生成帮助和使用手册，并在用户给程序传入无效参数时报出错误信息。</p>
<p>以下代码是一个 Python 程序，它获取一个整数列表并计算总和或者最大值：</p>
<pre><code class="python">import argparse

parser = argparse.ArgumentParser(description=&#39;Process some integers.&#39;)
parser.add_argument(&#39;integers&#39;, metavar=&#39;N&#39;, type=int, nargs=&#39;+&#39;,
                    help=&#39;an integer for the accumulator&#39;)
parser.add_argument(&#39;--sum&#39;, dest=&#39;accumulate&#39;, action=&#39;store_const&#39;,
                    const=sum, default=max,
                    help=&#39;sum the integers (default: find the max)&#39;)

args = parser.parse_args()
print args.accumulate(args.integers)
</code></pre>
<p>假设上面的 Python 代码保存在名为 <code>prog.py</code> 的文件中，它可以在命令行运行并提供有用的帮助信息：</p>
<pre><code class="python">$ python prog.py -h
usage: prog.py [-h] [--sum] N [N ...]

Process some integers.

positional arguments:
 N           an integer for the accumulator

optional arguments:
 -h, --help  show this help message and exit
 --sum       sum the integers (default: find the max)
</code></pre>
<p>当使用适当的参数运行时，它会输出命令行传入整数的总和或者最大值：</p>
<pre><code class="python">$ python prog.py 1 2 3 4
4

$ python prog.py 1 2 3 4 --sum
10
</code></pre>
<p>如果传入无效参数，则会报出错误：</p>
<pre><code class="python">$ python prog.py a b c
usage: prog.py [-h] [--sum] N [N ...]
prog.py: error: argument N: invalid int value: &#39;a&#39;
</code></pre>
<p>更多详情参考python文档，网址：<a href="https://docs.python.org/zh-cn/2/library/argparse.html">15.4. argparse — 命令行选项、参数和子命令解析器 — Python 2.7.18 文档</a></p>
<h3 id="Distuils"><a href="#Distuils" class="headerlink" title="Distuils"></a>Distuils</h3><p>大部分Python程序员都知道，有很多第三方包管理器供选择，包括setuptools、distribute等等。 有些是为了替代标准库中的distutils。</p>
<p>1.1概念和术语</p>
<p>对于模块开发者以及需要安装模块的使用者来说，Distutils的使用都很简单，作为一个开发者，除了编写源码之外，还需要：</p>
<p>·编写setup脚本（一般是setup.py）；</p>
<p>·编写一个setup配置文件（可选）；</p>
<p>·创建一个源码发布；</p>
<p>·创建一个或多个构建（二进制）发布（可选）;</p>
<p>有些模块开发者在开发时不会考虑多个平台发布，所以就有了packagers的角色，它们从模块开发者那取得源码发布，然后在多个平台上面进行构建，并发布多个平台的构建版本。</p>
<p>1.2简单例子</p>
<p>由python编写的setup脚本一般都非常简单。作为autoconf类型的配置脚本，setup脚本可以在构建和安装模块发布时运行多次。</p>
<p>比如，如果需要发布一个叫做foo的模块，它包含在一个文件foo.py，那setup脚本可以这样写：</p>
<pre><code class="python">from distutils.core import setup  
setup(name=&#39;foo&#39;,  
       version=&#39;1.0&#39;,  
       py_modules=[&#39;foo&#39;],  
      )  
</code></pre>
<p>setup函数的参数表示提供给Distutils的信息，这些参数分为两类：包的元数据（包名、版本号）以及包的信息（本例中是一个Python模块的列表）；模块由模块名表示，而不是文件名（对于包和扩展而言也是这样）；建议可以提供更多的元数据，比如你的名字，email地址和项目的URL地址。</p>
<p>编写好setup.py之后，就可以创建该模块的源码发布了：</p>
<pre><code class="python">python setup.py sdist  
</code></pre>
<p>sdist命令会创建一个archive 文件（比如Unix上的tar文件，Windows上的zip文件），它包含setup.py， foo.py。该archive文件命名为foo-1.0.tar.gz(zip)，解压之后的目录名是foo-1.0。</p>
<p>如果一个用户希望安装foo模块，他只需要下载foo-1.0.tar.gz，解压，进入foo-1.0目录，然后运行：</p>
<pre><code class="python">python setup.py install  
</code></pre>
<p>该命令最终会将foo.py复制到Python环境存放第三方模块的目录中。在linux环境下，运行该命令的输出是：</p>
<pre><code class="python"># python setup.py install  
running install  
running build  
running build_py  
creating build  
creating build/lib  
copying foo.py -&gt; build/lib  
running install_lib  
copying build/lib/foo.py -&gt; /usr/lib/python2.7/site-packages  
byte-compiling /usr/lib/python2.7/site-packages/foo.py to foo.pyc  
running install_egg_info  
Writing /usr/lib/python2.7/site-packages/foo-1.0-py2.7.egg-info  
</code></pre>
<p>该命令生成的文件是：</p>
<p><code>/usr/lib/python2.7/site-packages/foo-1.0-py2.7.egg-info</code></p>
<p><code>/usr/lib/python2.7/site-packages/foo.py</code></p>
<p><code>/usr/lib/python2.7/site-packages/foo.pyc</code></p>
<h3 id="图片缩放方式"><a href="#图片缩放方式" class="headerlink" title="图片缩放方式"></a>图片缩放方式</h3><p>对图像进行预处理操作的时候，一般有两种缩放方式。</p>
<ul>
<li>一种是直接宽、高缩放至想要的宽、高，这种方式快捷，但可能会导致图像变形<br> step1: 计算宽高缩放比例，选择较小的那个缩放系数；<br> step2: 计算缩放后的尺寸: 原始图片的长宽都乘以较小的缩放系数；<br> step3：计算短边需要填充的灰边数，将短边的两边各自填充一半的灰行即可。</li>
<li>一种是等比例缩放，然后用灰色边缘填充</li>
</ul>
<h4 id="直接缩放"><a href="#直接缩放" class="headerlink" title="直接缩放"></a>直接缩放</h4><p>代码实现如下：</p>
<p><code>new_image = image.resize((target_w, target_h), Image.BICUBIC)</code></p>
<img src="/2022/03/17/CN/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/image-20220406191420560.png" class="lazyload" data-srcset="/2022/03/17/CN/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/image-20220406191420560.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<h4 id="不变形缩放，两端填充灰边"><a href="#不变形缩放，两端填充灰边" class="headerlink" title="不变形缩放，两端填充灰边"></a>不变形缩放，两端填充灰边</h4><img src="/2022/03/17/CN/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/image-20220406191519097.png" class="lazyload" data-srcset="/2022/03/17/CN/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/image-20220406191519097.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<h4 id="不变形缩放，一端填充灰边"><a href="#不变形缩放，一端填充灰边" class="headerlink" title="不变形缩放，一端填充灰边"></a>不变形缩放，一端填充灰边</h4><img src="/2022/03/17/CN/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/image-20220406191620889.png" class="lazyload" data-srcset="/2022/03/17/CN/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/image-20220406191620889.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<p>很多图片的长宽比不同导致缩放填充后，两端的黑边大小都不同。而如果填充的比较多，则存在信息冗余，影响推理速度。YOLOv5作者对letterbox的缩放策略进行了修改，对原图自适应的添加最少的黑边。<br> <strong>计算方法：</strong><br> 1.计算原始图片宽高与输入尺寸的缩放比例rw和rh，选取r &#x3D; min(rw,rh)后把原图按r进行缩放<br> 2.原图宽和高中一定有一边完全贴合输入尺寸，没有达到输入尺寸的一边计算与输入尺寸的差值，然后进行上下（or左右）的填充。</p>
<p>代码如下：</p>
<pre><code class="python">import matplotlib.pyplot as plt
from PIL import Image

# ---------------------------------------------------#
#   对输入图像进行resize,他人测试发现，不用letterbox_image直接resize的效果更好
# ---------------------------------------------------#
def resize_image(image, size, letterbox_image):
    iw, ih  = image.size
    w, h    = size      # w=200, h=300
    if letterbox_image:
        scale   = min(w/iw, h/ih)
        nw      = int(iw*scale)
        nh      = int(ih*scale)

        image   = image.resize((nw,nh), Image.BICUBIC)
        new_image = Image.new(&#39;RGB&#39;, size, (128,128,128))       # 新建一张image，第二个参数表示尺寸，第三个参数表示颜色
        # --------------------------------------------------#
        #   image.paste函数表示将一张图片覆盖到另一张图片的指定位置去
        #   a.paste(b, (50,50))   将b的左上顶点贴到a的坐标为（50，50）的位置，左上顶点为(0,0), b超出a的部分会被自动舍弃
        # ---------------------------------------------------#
        # new_image.paste(image, ((w-nw)//2, (h-nh)//2))    # 不变形resize，两端填充灰边
        new_image.paste(image, (0, 0))      # 不变形resize，一端填充灰边
    else:
        new_image = image.resize((w, h), Image.BICUBIC)
    return new_image


img_PIL = Image.open(&quot;Avatar.jpg&quot;)
img = resize_image(img_PIL, (200, 300), True)   # 第二参数表示目标尺寸，第三参数表示是否使用letterbox
plt.imshow(img)
plt.show()
# 作者：寻找永不遗憾
# 链接：https://www.jianshu.com/p/2ae3a497f5f4
# 来源：简书
# 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<h3 id="图像resize插值方式比较"><a href="#图像resize插值方式比较" class="headerlink" title="图像resize插值方式比较"></a>图像resize插值方式比较</h3><p>resize函数说明：</p>
<p><code>void resize(InputArray src, OutputArray dst,  Size dsize, double fx=0, double fy=0, int interpolation=INTER_LINEAR)</code></p>
<p>参数说明：</p>
<p><code>src</code>：输入，原图像，即待改变大小的图像；<br><code>dst</code>：输出，改变大小之后的图像，这个图像和原图像具有相同的内容，只是大小和原图像不一样而已；<br><code>dsize</code>：输出图像的大小。如果这个参数不为0，那么就代表将原图像缩放到这个Size(width，height)指定的大小；如果这个参数为0，那么原图像缩放之后的大小就要通过下面的公式来计算：<br>$$<br>dsize &#x3D; Size(round(fx<em>src.cols), round(fy</em>src.rows))<br>$$<br> 其中，fx和fy就是下面要说的两个参数，是图像width方向和height方向的缩放比例。</p>
<p><code>fx</code>：width方向的缩放比例，如果它是0，那么它就会按照(double)dsize.width&#x2F;src.cols来计算；<br><code>fy</code>：height方向的缩放比例，如果它是0，那么它就会按照(double)dsize.height&#x2F;src.rows来计算；<br><code>interpolation</code>：这个是指定插值的方式，图像缩放之后，肯定像素要进行重新计算的，就靠这个参数来指定重新计算像素的方式，有以下几种：<br>      ·<code>INTER_NEAREST</code> - 最邻近插值<br>      ·<code>INTER_LINEAR</code> - 双线性插值，如果最后一个参数你不指定，默认使用这种方法<br>      ·<code>INTER_AREA </code>-区域插值<br>      ·<code>INTER_CUBIC</code> - 4x4像素邻域内的双立方插值<br>     ·<code>INTER_LANCZOS4</code>- 8x8像素邻域内的Lanczos插值</p>
<p>各种插值方式比较：</p>
<p>每种插值算法的前部分代码是相同的，如下：</p>
<pre><code class="python">    cv::Mat matSrc, matDst1, matDst2;
 
    matSrc = cv::imread(&quot;lena.jpg&quot;, 2 | 4);
    matDst1 = cv::Mat(cv::Size(800, 1000), matSrc.type(), cv::Scalar::all(0));
    matDst2 = cv::Mat(matDst1.size(), matSrc.type(), cv::Scalar::all(0));
 
    double scale_x = (double)matSrc.cols / matDst1.cols;
    double scale_y = (double)matSrc.rows / matDst1.rows;
</code></pre>
<p>最近邻：<br>$$<br>X_{src}&#x3D;X_{dst}<em>(Width_{src}&#x2F;Width_{dst})\<br>Y_{src}&#x3D;Y_{dst}</em>(Height_{src}&#x2F;Height_{dst})<br>$$<br>实现代码如下：</p>
<pre><code class="python">    for (int i = 0; i &lt; matDst1.cols; ++i)
    &#123;
        int sx = cvFloor(i * scale_x);
        sx = std::min(sx, matSrc.cols - 1);
        for (int j = 0; j &lt; matDst1.rows; ++j)
        &#123;
            int sy = cvFloor(j * scale_y);
            sy = std::min(sy, matSrc.rows - 1);
            matDst1.at&lt;cv::Vec3b&gt;(j, i) = matSrc.at&lt;cv::Vec3b&gt;(sy, sx);
        &#125;
    &#125;
    cv::imwrite(&quot;nearest_1.jpg&quot;, matDst1);
 
    cv::resize(matSrc, matDst2, matDst1.size(), 0, 0, 0);
    cv::imwrite(&quot;nearest_2.jpg&quot;, matDst2);
</code></pre>
<p>双线性：<br>$$<br>Dst(X, Y)&#x3D;(1-u)<em>(1-v)<em>Src(X’,Y’)+(1-u)<em>v</em>Src(X’, Y’+1)+\<br>        u</em>(1-v)<em>Src(X’+1, Y’)+u</em>v</em>Src(X’+1, Y’+1)<br>$$</p>
<pre><code class="python">    uchar* dataDst = matDst1.data;
    int stepDst = matDst1.step;
    uchar* dataSrc = matSrc.data;
    int stepSrc = matSrc.step;
    int iWidthSrc = matSrc.cols;
    int iHiehgtSrc = matSrc.rows;
 
    for (int j = 0; j &lt; matDst1.rows; ++j)
    &#123;
        float fy = (float)((j + 0.5) * scale_y - 0.5);
        int sy = cvFloor(fy);
        fy -= sy;
        sy = std::min(sy, iHiehgtSrc - 2);
        sy = std::max(0, sy);
 
        short cbufy[2];
        cbufy[0] = cv::saturate_cast&lt;short&gt;((1.f - fy) * 2048);
        cbufy[1] = 2048 - cbufy[0];
 
        for (int i = 0; i &lt; matDst1.cols; ++i)
        &#123;
            float fx = (float)((i + 0.5) * scale_x - 0.5);
            int sx = cvFloor(fx);
            fx -= sx;
 
            if (sx &lt; 0) &#123;
                fx = 0, sx = 0;
            &#125;
            if (sx &gt;= iWidthSrc - 1) &#123;
                fx = 0, sx = iWidthSrc - 2;
            &#125;
 
            short cbufx[2];
            cbufx[0] = cv::saturate_cast&lt;short&gt;((1.f - fx) * 2048);
            cbufx[1] = 2048 - cbufx[0];
 
            for (int k = 0; k &lt; matSrc.channels(); ++k)
            &#123;
                *(dataDst+ j*stepDst + 3*i + k) = (*(dataSrc + sy*stepSrc + 3*sx + k) * cbufx[0] * cbufy[0] + 
                    *(dataSrc + (sy+1)*stepSrc + 3*sx + k) * cbufx[0] * cbufy[1] + 
                    *(dataSrc + sy*stepSrc + 3*(sx+1) + k) * cbufx[1] * cbufy[0] + 
                    *(dataSrc + (sy+1)*stepSrc + 3*(sx+1) + k) * cbufx[1] * cbufy[1]) &gt;&gt; 22;
            &#125;
        &#125;
    &#125;
    cv::imwrite(&quot;linear_1.jpg&quot;, matDst1);
 
    cv::resize(matSrc, matDst2, matDst1.size(), 0, 0, 1);
    cv::imwrite(&quot;linear_2.jpg&quot;, matDst2);
</code></pre>
<p>双三次：</p>
<pre><code class="python">int iscale_x = cv::saturate_cast&lt;int&gt;(scale_x);
int iscale_y = cv::saturate_cast&lt;int&gt;(scale_y);
 
for (int j = 0; j &lt; matDst1.rows; ++j)
&#123;
    float fy = (float)((j + 0.5) * scale_y - 0.5);
    int sy = cvFloor(fy);
    fy -= sy;
    sy = std::min(sy, matSrc.rows - 3);
    sy = std::max(1, sy);
 
    const float A = -0.75f;
 
    float coeffsY[4];
    coeffsY[0] = ((A*(fy + 1) - 5*A)*(fy + 1) + 8*A)*(fy + 1) - 4*A;
    coeffsY[1] = ((A + 2)*fy - (A + 3))*fy*fy + 1;
    coeffsY[2] = ((A + 2)*(1 - fy) - (A + 3))*(1 - fy)*(1 - fy) + 1;
    coeffsY[3] = 1.f - coeffsY[0] - coeffsY[1] - coeffsY[2];
 
    short cbufY[4];
    cbufY[0] = cv::saturate_cast&lt;short&gt;(coeffsY[0] * 2048);
    cbufY[1] = cv::saturate_cast&lt;short&gt;(coeffsY[1] * 2048);
    cbufY[2] = cv::saturate_cast&lt;short&gt;(coeffsY[2] * 2048);
    cbufY[3] = cv::saturate_cast&lt;short&gt;(coeffsY[3] * 2048);
 
    for (int i = 0; i &lt; matDst1.cols; ++i)
    &#123;
        float fx = (float)((i + 0.5) * scale_x - 0.5);
        int sx = cvFloor(fx);
        fx -= sx;
 
        if (sx &lt; 1) &#123;
            fx = 0, sx = 1;
        &#125;
        if (sx &gt;= matSrc.cols - 3) &#123;
            fx = 0, sx = matSrc.cols - 3;
        &#125;
 
        float coeffsX[4];
        coeffsX[0] = ((A*(fx + 1) - 5*A)*(fx + 1) + 8*A)*(fx + 1) - 4*A;
        coeffsX[1] = ((A + 2)*fx - (A + 3))*fx*fx + 1;
        coeffsX[2] = ((A + 2)*(1 - fx) - (A + 3))*(1 - fx)*(1 - fx) + 1;
        coeffsX[3] = 1.f - coeffsX[0] - coeffsX[1] - coeffsX[2];
 
        short cbufX[4];
        cbufX[0] = cv::saturate_cast&lt;short&gt;(coeffsX[0] * 2048);
        cbufX[1] = cv::saturate_cast&lt;short&gt;(coeffsX[1] * 2048);
        cbufX[2] = cv::saturate_cast&lt;short&gt;(coeffsX[2] * 2048);
        cbufX[3] = cv::saturate_cast&lt;short&gt;(coeffsX[3] * 2048);
 
        for (int k = 0; k &lt; matSrc.channels(); ++k)
        &#123;
            matDst1.at&lt;cv::Vec3b&gt;(j, i)[k] = abs((matSrc.at&lt;cv::Vec3b&gt;(sy-1, sx-1)[k] * cbufX[0] * cbufY[0] + matSrc.at&lt;cv::Vec3b&gt;(sy, sx-1)[k] * cbufX[0] * cbufY[1] +
                matSrc.at&lt;cv::Vec3b&gt;(sy+1, sx-1)[k] * cbufX[0] * cbufY[2] + matSrc.at&lt;cv::Vec3b&gt;(sy+2, sx-1)[k] * cbufX[0] * cbufY[3] +
                matSrc.at&lt;cv::Vec3b&gt;(sy-1, sx)[k] * cbufX[1] * cbufY[0] + matSrc.at&lt;cv::Vec3b&gt;(sy, sx)[k] * cbufX[1] * cbufY[1] +
                matSrc.at&lt;cv::Vec3b&gt;(sy+1, sx)[k] * cbufX[1] * cbufY[2] + matSrc.at&lt;cv::Vec3b&gt;(sy+2, sx)[k] * cbufX[1] * cbufY[3] +
                matSrc.at&lt;cv::Vec3b&gt;(sy-1, sx+1)[k] * cbufX[2] * cbufY[0] + matSrc.at&lt;cv::Vec3b&gt;(sy, sx+1)[k] * cbufX[2] * cbufY[1] +
                matSrc.at&lt;cv::Vec3b&gt;(sy+1, sx+1)[k] * cbufX[2] * cbufY[2] + matSrc.at&lt;cv::Vec3b&gt;(sy+2, sx+1)[k] * cbufX[2] * cbufY[3] +
                matSrc.at&lt;cv::Vec3b&gt;(sy-1, sx+2)[k] * cbufX[3] * cbufY[0] + matSrc.at&lt;cv::Vec3b&gt;(sy, sx+2)[k] * cbufX[3] * cbufY[1] +
                matSrc.at&lt;cv::Vec3b&gt;(sy+1, sx+2)[k] * cbufX[3] * cbufY[2] + matSrc.at&lt;cv::Vec3b&gt;(sy+2, sx+2)[k] * cbufX[3] * cbufY[3] ) &gt;&gt; 22);
        &#125;
    &#125;
&#125;
cv::imwrite(&quot;cubic_1.jpg&quot;, matDst1);
 
cv::resize(matSrc, matDst2, matDst1.size(), 0, 0, 2);
cv::imwrite(&quot;cubic_2.jpg&quot;, matDst2);
</code></pre>
<p>基于像素区域关系：共分三种情况，图像放大时类似于双线性插值，图像缩小(x轴、y轴同时缩小)又分两种情况，此情况下可以避免波纹出现</p>
<p>具体实现代码可以参考<a href="https://github.com/fengbingchun/OpenCV_Test/blob/master/src/fbc_cv/include/resize.hpp%EF%BC%8C%E7%94%A8%E6%B3%95%E5%A6%82%E4%B8%8B%EF%BC%9A">https://github.com/fengbingchun/OpenCV_Test/blob/master/src/fbc_cv/include/resize.hpp，用法如下：</a></p>
<pre><code class="python">fbc::Mat3BGR src(matSrc.rows, matSrc.cols, matSrc.data);
fbc::Mat3BGR dst(matDst1.rows, matDst1.cols, matDst1.data);
fbc::resize(src, dst, 3);
</code></pre>
<p>兰索斯插值：略</p>
<p>测试代码：</p>
<pre><code class="c++">#include &lt;chrono&gt;
#include &lt;opencv2/opencv.hpp&gt;
#define  millisecond 1000000
#define DEBUG_PRINT(...)  printf( __VA_ARGS__); printf(&quot;\n&quot;)
#define DEBUG_TIME(time_) auto time_ =std::chrono::high_resolution_clock::now()
#define RUN_TIME(time_)  (double)(time_).count()/millisecond
using namespace std;
 
cv::Mat image_resize(cv::Mat image, int width, int height, int interpolation, int num) &#123;
    cv::Mat dest;
    for (int i = 0; i &lt; num; ++i) &#123;
        cv::resize(image, dest, cv::Size(width, height), 0, 0, interpolation);//最近邻插值
    &#125;
    return dest;
&#125;
 
 
int main() &#123;
    string path = &quot;../1.jpg&quot;;
    cv::Mat image = cv::imread(path);
    cv::resize(image, image, cv::Size(1000, 1000));
    int re_width = 900;
    int re_height = 900;
    int  num=10;
    cv::Mat image2X_INTER_NEAREST;
    cv::Mat image2X_INTER_LINEAR;
    cv::Mat image2X_INTER_AREA;
    cv::Mat image2X_INTER_CUBIC;
    cv::Mat initMat;
    DEBUG_PRINT(&quot;image input size:%dx%d&quot;, image.rows, image.cols);
    DEBUG_TIME(T0);
    image2X_INTER_NEAREST=image_resize(image, re_width, re_height, cv::INTER_NEAREST, num);
    DEBUG_TIME(T1);
    image2X_INTER_LINEAR=image_resize(image, re_width, re_height, cv::INTER_LINEAR, num);
    DEBUG_TIME(T2);
    image2X_INTER_AREA=image_resize(image, re_width, re_height, cv::INTER_AREA, num);
    DEBUG_TIME(T3);
    image2X_INTER_CUBIC=image_resize(image, re_width, re_height, cv::INTER_CUBIC, num);
    DEBUG_TIME(T4);
    DEBUG_PRINT(&quot;resize_image:%dx%d,INTER_NEAREST:%3.3fms&quot;,
            image2X_INTER_NEAREST.rows,
            image2X_INTER_NEAREST.cols,
            RUN_TIME(T1 - T0)/num);
    DEBUG_PRINT(&quot;resize_image:%dx%d,INTER_LINEAR :%3.3fms&quot;,
            image2X_INTER_LINEAR.rows,
            image2X_INTER_LINEAR.cols,
            RUN_TIME(T2 - T1)/num);
    DEBUG_PRINT(&quot;resize_image:%dx%d,INTER_AREA   :%3.3fms&quot;,
            image2X_INTER_AREA.rows,
            image2X_INTER_AREA.cols,
            RUN_TIME(T3 - T2)/num);
    DEBUG_PRINT(&quot;resize_image:%dx%d,INTER_CUBIC  :%3.3fms&quot;,
            image2X_INTER_CUBIC.rows,
            image2X_INTER_CUBIC.cols,
            RUN_TIME(T4 - T3)/num);
    return 0;
&#125;
版权声明：本文为CSDN博主「pan_jinquan」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/guyuealian/article/details/85097633
</code></pre>
<p>运行结果：</p>
<pre><code>image input size:1000x1000
resize_image:900x900,INTER_NEAREST:0.389ms
resize_image:900x900,INTER_LINEAR :0.605ms
resize_image:900x900,INTER_AREA   :2.611ms
resize_image:900x900,INTER_CUBIC  :1.920ms
</code></pre>
<p>总结：</p>
<pre><code class="markdown"> 速度比较：INTER_NEAREST（最近邻插值)&gt;INTER_LINEAR(线性插值)&gt;INTER_CUBIC(三次样条插值)&gt;INTER_AREA  (区域插值)
对图像进行缩小时，为了避免出现波纹现象，推荐采用INTER_AREA 区域插值方法。
OpenCV推荐：如果要缩小图像，通常推荐使用#INTER_AREA插值效果最好，而要放大图像，通常使用INTER_CUBIC(速度较慢，但效果最好)，或者使用INTER_LINEAR(速度较快，效果还可以)。至于最近邻插值INTER_NEAREST，一般不推荐使用
</code></pre>
<p>更多详情参考：<a href="https://docs.opencv.org/3.2.0/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d">OpenCV: Geometric Image Transformations</a></p>
]]></content>
  </entry>
  <entry>
    <title>pytorch官方文档中文版</title>
    <url>/2022/03/25/en/pytorch%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="torch-nn"><a href="#torch-nn" class="headerlink" title="torch.nn"></a>torch.nn</h1><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>CLASS    <code>torch.nn.Module</code>    <a href="https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module">SOURCE</a></p>
<p>它是所有神经网络模型的基类，你的模块应该继承于该类。</p>
<p>模块还能包含其他模块，允许把它们嵌套在一个树结构中。你可以分配子模块作为常规属性：</p>
<pre><code class="python">import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1 = nn.Conv2d(1, 20, 5)
        self.conv2 = nn.Conv2d(20, 20, 5)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        return F.relu(self.conv2(x))
</code></pre>
<p>用这种方式分配的模块将会显示，并且当你调用<code>to( )</code>等等方法，它们的参数也将被转换。</p>
<p>注：</p>
<p>正如上面的例子一样，一个<code>__init__()</code>调用父类必须在子类赋值之前完成。</p>
<hr>
<p>变量</p>
<p><code>training(bool)</code>-布尔值代表这个模块是训练模式还是评估模式</p>
<p><code>add_module(name,    module)</code>    <a href="https://pytorch.org/docs/stable/_modules/torch/nn/modules/module.html#Module.add_module">SOURCE</a></p>
<p>​                添加一个子模块到当前模块</p>
<p>​                这个模块可以用给定的名称作为属性访问模块</p>
<p>​                参数：</p>
<p>​                        ·name(string)-子模块的名字，这个子模块可以用给定的名称作为属性访问。</p>
<p>​                        ·module(Module)-子模块添加到模块上</p>
]]></content>
      <categories>
        <category>pytorch</category>
      </categories>
      <tags>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title>学习网站集合</title>
    <url>/2022/03/14/en/%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="万门好课"><a href="#万门好课" class="headerlink" title="万门好课"></a>万门好课</h2><p><a href="https://www.wanmen.org/" title="加油吧少年">万门好课</a>是一家提供多品类原创精品课程的在线教育平台 ，课程覆盖IT与互联网类、职业成长类、经济金融类、本科学习类等领域 。 整体课程定位侧重于“用户刚需”类课程，如语言版块的出国英语考试类课程、小语种培训课程，本科学习版块的各学科基础大课，以及特色的万门通识课程包括PS、化妆等。</p>
<h2 id="网易云课堂"><a href="#网易云课堂" class="headerlink" title="网易云课堂"></a>网易云课堂</h2><p><a href="https://study.163.com/">网易云课堂</a>立足于实用性的要求，网易云课堂与多家教育、培训机构建立合作，课程数量已达4100+，课时总数超50000,涵盖实用软件、IT与互联网、外语学习、生活家居、兴趣爱好、职场技能、金融管理、考试认证、中小学、亲子教育等十余大门类。</p>
<h2 id="网易公开课"><a href="#网易公开课" class="headerlink" title="网易公开课"></a>网易公开课</h2><p><a href="https://open.163.com/">网易公开课</a>首批1200集课程上线，其中有200多集配有中文字幕。用户可以在线免费观看来自于哈佛大学等世界级名校的公开课课程，可汗学院，TED等教育性组织的精彩视频，内容涵盖人文、社会、艺术、科学、金融等领域。 力求为爱学习的网友创造一个公开的免费课程平台，借此向外界公开招聘兼职字幕翻译。</p>
<h2 id="爱课程网"><a href="#爱课程网" class="headerlink" title="爱课程网"></a>爱课程网</h2><p><a href="https://www.icourses.cn/home">爱课程网</a>利用现代信息技术和网络技术， 面向高校师生和社会大众。提供优质教育资源共享和个性化教学资源服务，具有资源浏览、搜索、重组、评价、课程包的导入导出、发布、互动参与和“教”“学”兼备等功能。</p>
<h2 id="粉笔网"><a href="#粉笔网" class="headerlink" title="粉笔网"></a>粉笔网</h2><p><a href="https://www.fenbi.com/">粉笔网</a>是一个互联网教育平台，业务包含：公务员考试，考研、教师资格、事业单位、英语、建造、财会等技能培训；利用技术手段实现智能批改功能，并提供免费题库，供用户查阅学习，利用网络直播，进行线上授课，同时提供实物图书、试卷以及客户服务。</p>
]]></content>
      <categories>
        <category>学习网站</category>
      </categories>
      <tags>
        <tag>学习网站</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记</title>
    <url>/2022/03/17/en/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>tf中矩阵量存在形式常用有三种，具体如下：<br>1.tf.Variable()<br>表示神经网络中可变化的量（可以通过trainable&#x3D;False设置成不可变),可在运行中赋值，可以通过constant或者其他方式进行初始化。<br>2.tf.constant()<br>可以通过numpy中的array或者list,还有给定的shape和数值进行赋值<br>3.tf.placeholder()<br>相当于占位符，也是有shape的量，因为训练过程中需要不断赋值和替换值，而整体计算的结构是不变的。<br>代码：<br>&#x2F;&#x2F;导包</p>
<p><code>import tensorflow as tf    </code>    </p>
<p>&#x2F;&#x2F;定义变量<br><code>A = tf.Variable(tf.ones([4,4]))    </code></p>
<p>&#x2F;&#x2F;变量初始化<br><code>import numpy as np       cst = tf.constant(np.ones([4,4]),dtype=tf.float32)        </code><br>#需要指定类型dtype&#x3D;tf.float32,tf中不能隐式转换浮点和整型<br>#cst &#x3D; tf.constant(1.0,shape&#x3D;[4,4],dtype&#x3D;tf.float32)也是可以的<br><code>A = tf.Variable(cst)</code></p>
<p>&#x2F;&#x2F;定义placeholder<br><code>X = tf.placeholder(dtype=tf.float32,shape=[4,1])</code></p>
<p>&#x2F;&#x2F;矩阵相乘<br><code>C = tf.matmul(A,X)</code></p>
<p>&#x2F;&#x2F;定义Session<br><code>sess = tf.Session()</code></p>
<p>&#x2F;&#x2F;初始化变量<br><code>init = tf.global_variables_initializer()</code></p>
<p>&#x2F;&#x2F;执行初始化<br><code>sess.run(init)</code></p>
<p>&#x2F;&#x2F;运行矩阵相乘<br><code>sess.run(C,feed_dict=&#123;X:[[1],[1],[1],[1]]&#125;)</code></p>
<p>&#x2F;&#x2F;获取变量值<br><code>A_val = A.value()   Avalue = sess.run(A_val)</code></p>
<p>&#x2F;&#x2F;完整矩形相乘代码<br><code>import tensorflow as tf   import numpy as np</code></p>
<p><code>X = tf.placeholder(dtype=tf.float32,shape=[4,1])   A = tf.Variable(tf.zeros([4,4]))   C = tf.matmul(A,X)   sess = tf.session()   init = tf.global_variables_initializer()   sess.run(init)   print(sess.run(A))  </code></p>
<p>&#x2F;&#x2F;为了使计算图更加清晰，可以使用variable_scope()<br>&#x2F;&#x2F;定义变量名称<br><code>with  tf.variable_scope(&quot;first-nn-layer&quot;):     W = tf.Variable(tf.zeros([784,10]),name=&quot;W&quot;)     b = tf.Variable(tf.zeros([10]),name=&quot;b&quot;)     y = tf.matmul(x,W)+b     variable_summaries(W)</code></p>
<p>&#x2F;&#x2F;标识不同的变量<br>&#x2F;&#x2F;不同作用域下的同名变量<br><code>with tf.variable_scope(&quot;first-nn-layer&quot;):     W = tf.Variable(tf.zeros([784,10]),name=&quot;W&quot;)     b = tf.Variable(tf.zeros([10]),name=&quot;b&quot;)     W1 = tf.Variable(tf.zeros([784,10]),name=&quot;W&quot;) print(W.name) print(W1.name)</code><br>#w、w1虽然name一样，但是计算中依然当成不同的变量，让同一个scope的同一变量可以通过get_variable()函数</p>
<p>&#x2F;&#x2F;获取变量<br><code>with tf.variable_scope(&quot;first-nn-layer&quot;) as scope:     W = tf.get_variable(&quot;W&quot;,[784, 10])     b = tf.get_variable(&quot;b&quot;,[10])     scope.reuse_variables()#缺少则会报错     W1 = tf.get_variables(&quot;W&quot;,shape=[784,10]) print(W.name) print(W1.name)</code><br>#w、w1属于同一个变量</p>
<p>注：若此时缺少了scope.reuse_variables()则会报错，因为同时引用了同一个变量，对于不同层的变量，可以利用variable_scope进行区分，在再次引入相关变量时，需要加上reuse&#x3D;True,否则依然会报错。如果变量不存在时加上reuse&#x3D;True,依然会报错，因为该变量不存在</p>
<p><code>with tf.variable_scope(&quot;first-nn-layer&quot;) as scope:     W = tf.get_variable(&quot;W&quot;,[784, 10])     b = tf.get_variable(&quot;b&quot;,[10]) with tf.variable_scope(&quot;second-nn-layer&quot;) as scope:     W = tf.get_variable(&quot;W&quot;,[784, 10])     b = tf.get_variable(&quot;b&quot;,[10]) with tf.variable_scope(&quot;second-nn-layer&quot;, reuse=True) as scope:     W3 = tf.get_variable(&quot;W&quot;,[784, 10])     b3 = tf.get_variable(&quot;b&quot;,[10]) print(W.name) print(W3.name)</code></p>
<p>&#x2F;&#x2F;保存模型<br>&#x2F;&#x2F;定义saver<br><code>saver = tf.train.Saver()</code></p>
<p>&#x2F;&#x2F;在训练过程中进行保存，保存为训练过程中的变量<br>&#x2F;&#x2F;变量保存<br><code>for itr in range(1000):     ...     saver.save(sess,&quot;model/al&quot;,global_step=itr)</code></p>
<p>&#x2F;&#x2F;加载计算<br>&#x2F;&#x2F;变量载入<br><code>saver.restore(sess,&quot;model/v2-200&quot;)</code></p>
<p>3.4构建计算图<br>&#x2F;&#x2F;前面在描述计算图，这里观察所建立的计算图<br>&#x2F;&#x2F;定义summary<br><code>train_writer = tf.summary.FileWriter(&quot;logdir&quot;,sess.graph)</code></p>
<p>注：sess.graph就是描绘的计算图，”logdir”是log的存储文件夹。在Shell中运行Tensorboard,在浏览器中输入localhost:6006,然后点击graph就可以看到设计的网络模型了。</p>
<p>&#x2F;&#x2F;问题：描绘的计算图非常杂乱无章，变量命名的可读性很差，需要进行整理。<br>&#x2F;&#x2F;变量命名<br><code>x = tf.placeholder(tf.float32,[None,784],name=&quot;input_x&quot;) label = tf.placeholder(tf.float32,[None,10],name=&quot;input_label&quot;) W = tf.Variable(tf.zeros([874,10]),name=&quot;W&quot;) b = tf.Variable(tf.zeros([10]),name=&quot;b&quot;)</code></p>
<p>&#x2F;&#x2F;问题：依然不够清楚，可以将输入层的x和label归为一类<br>&#x2F;&#x2F;定义作用域<br><code>with tf.variable_scope(&quot;input&quot;):     x = tf.placeholder(tf.float32,[None,784],name=&quot;input_x&quot;)     label = tf.placeholder(tf.float32,[None,10],name=&quot;input_label&quot;) with tf.variable_scope(&quot;first-nn-layer&quot;):     W = tf.Variable(tf.zeros([784,10]), name=&quot;W&quot;)     b = tf.Variable(tf.zeros([10]),name=&quot;b&quot;)     y = tf.matmul(x,W)+b with tf.variable_scope(&quot;loss&quot;):     loss = tf.reduce_mean(tf.square(y-label))</code></p>
<p>&#x2F;&#x2F;同一作用域下的同名变量是相同的，涉及到变量复用的问题，以及后续变量的获取，为了观察变量的变化，需要观察的变量加入summary函数<br>&#x2F;&#x2F;定义summary函数<br><code>def variable_summaries(var):     with tf.name_scope(&#39;summaries&#39;):         mean = tf.reduce_mean(var)         tf.summary.scalar(&#39;mean&#39;,mean)         with tf.name_scope(&#39;stddev&#39;):             stddev = tf.sqrt(tf.reduce_mean(tf.square(var-mean)))         tf.summary.scalar(&#39;stddev&#39;,stddev)         tf.summary.scalar(&#39;max&#39;,tf.reduce_max(var))         tf.summary.scalar(&#39;min&#39;,tf.reduce_min(var))         tf.summary.histogram(&#39;histogram&#39;,var)</code></p>
<p>&#x2F;&#x2F;若要观测W的相关情况，调用summary函数<br>&#x2F;&#x2F;调用summary函数<br><code>variable_summaries(W)</code></p>
<p>&#x2F;&#x2F;再用merge_all函数收集summary信息<br>&#x2F;&#x2F;获取summary信息<br><code>merged = tf.summary.merge_all()</code></p>
<p>&#x2F;&#x2F;summary保存<br><code>summary = sess.run(merged, feed_dict=&#123;x:batch_xs,label:batch_ys&#125;) train_writer.add_summary(summary,itr)</code></p>
<p>注：此时可以在网页中访问，观察变量随迭代变化的情况，可以通过不同的方式对变量进行观测，比如时序统计、histogram,这些统计信息对于分析训练过程是非常重要的</p>
<p>3.5全连接网络构建<br>&#x2F;&#x2F;tf官方手写识别版本的简化版本<br>&#x2F;&#x2F;单层全连接网络<br>#引入库<br><code>from tensorflow.examples.tutorials.mnist import input_data#产生数据，手写识别的图片和标签 import tensorflow as tf</code></p>
<p>#获取数据<br><code>mnist = input_data.read_data_sets(&quot;MNIST_data/&quot;,one_hot=True)</code><br>#构建网络模型<br>#x,label分别为图形数据和标签数据<br><code>x = tf.placeholder(tf.float32,[None,784]) label = tf.placeholder(tf.float32,[None,10])</code><br>#构建单层网络中的权值和偏置<br><code>W = tf.Variable(tf.zeros([784,10])) b = tf.Variable(tf.zeros([10])</code><br>#本例中无非线性激活函数<br><code>y = tf.matmul(x,W)+b</code><br>#定义损失函数为欧氏距离，但这并不是最好的，多分类问题通常使用交叉熵<br><code>loss = tf.reduce_mean(tf.square(y-label))</code><br>#若使用交叉熵损失函数<br><code>soft_max = tf.nn.softmax(logit, axis=1) loss = tf.reduce_mean(-label*tf.log(soft_max))</code><br>#用梯度迭代算法<br><code>train_step = tf.train.GradientDescentOptimizer(0.005).minimize(loss)</code><br>#用于验证<br><code>correct_prediction = tf.equal(tf.argmax(y,1),tf.argmax(label,1)) accuracy = tf.reduce_mean(tf.cast(correct_prediction,tf.float.32))</code><br>#定义会话<br><code>sess = tf.Session()</code><br>#初始化所有变量<br><code>sess.run(tf.global_variable_initializer())</code><br>#迭代过程<br><code>for itr in range(3000):     batch_xs,batch_ys = mnist.train.next_batch(100)     sess.run(train_step, feed_dict=&#123;x:batch_xs,label:batch_ys&#125;)     if itr%10==0:         print(&quot;step:%6d accuracy:&quot;%iter, sess.run(accuracy, feed_dict=&#123;x:mnist.test.images, label:mnist.test.labels&#125;))</code></p>
<p>#获取W取值<br><code>W_value = sess.run(W.value())</code></p>
<p>&#x2F;&#x2F;定义一个单层全连接函数<br><code>def full_layer(input_tensor, out_dim, name=&quot;full&quot;):     with tf.variable_scope(name):         shape = input_tensor.get_shape()as_list()         W = tf.get_variable(&#39;W&#39;,(shape[1],out_dim),dtype=tf.float32, initalizer=tf.truncated_normal_initializer(stddev=0.1))         b = tf.get_variable(&#39;b&#39;,[out_dim], dtype=tf.float32, initializer=tf.constant_initializer(0))         out = tf.matmul(input_tensor, W)+b     return tf.nn.sigmoid(nn)</code></p>
<p>3.6CNN构建<br>&#x2F;&#x2F;CNN手写识别<br>#预读取MNIST手写字库<br><code>from tensorflow.examples.tutorials.mnist import input_data   mnist = input_data.read_data_sets(&quot;MNIST_data&quot;,one_hot=True)</code></p>
<p><code>import tensorflow as tf</code><br>#用正态分布随机数初始化变量，本例中仅作为权值<br><code>def weight_variable(shape):     initial=tf.truncated_normal(shape,stddev=0.1)</code><br>    #正态分布<br>    <code>return tf.Variable(initial)</code><br>#用常量方式初始化偏置<br><code>def bias_variable(shape):     initial=tf.constant(0.1,shape=shape)</code><br>    #常数分布<br>       <code>return tf.Variable(initial)</code><br>#定义二维卷积的过程<br>def conv2d(x,W):<br>    return tf.nn.conv2d(x,W,strides&#x3D;[1,1,1,1],padding&#x3D;’SAME’)<br>#定义池化层，简单地说就是选个最大的数，进一步降低自由参数的个数<br><code>def max_pool_2x2(x):     return tf.nn.max_pool(x,ksize=[1,2,2,1],strides=[1,2,2,1],padding=&#39;SAME&#39;)</code></p>
<p><code>x = tf.placeholder(tf.float32,shape=[100,784]) y = tf.placeholder(tf.float32,shape=[100,10])</code></p>
<p><code>W_conv1 = weight_variable([5,5,1,32]) b_conv1 = bias_variable([32]) x_image = tf.reshape(x,[-1,28,28,1]) y_conv1 = tf.nn.relu(conv2d(x_iamge,W_conv1)+b_conv1) y_pool1 = max_pool_2x2(y_conv1)</code></p>
<p><code>W_conv2 = weight_variable([5,5,32,64]) b_conv2 = weight_variable([64]) y_conv2 = tf.nn.relu(conv2d(y_pool1,W_conv2)+b_conv2) y_pool2 = max_pool_2x2(y_conv2)</code></p>
<p><code>y_fc_flat = tf.reshape(y_pool2,[-1,7*7*64]) W_fc1 = weight_variable([7*7*64,10]) b_fc1 = bias_variable([10]) y_fc1 = tf.nn.relu(tf.matmul(y_fc_flat,W_fc1)+b_fc1)</code></p>
<p><code>cross_entropy = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=y,logits=y_fc1)) train_step = tf.train.AdamOptimizer(1e-4).minimize(cross_entropy)</code></p>
<p><code>sess = tf.Session() init = tf.global_variables_initializer() sess.run(init)</code></p>
<p><code>for i in range(1000):     bx,by = mnist.train.next_batch(100)     sess.run(train_step,feed_dict=&#123;x:bx,y:by&#125;)</code></p>
<p><code>import numpy as np import matplotlib.pyplot as plt</code><br>#设置输出风格，为画图美观<br><code>import matplotlib  as mpl mpl.style.use(&#39;seaborn-darkgrid&#39;)</code></p>
<p><code>val = W_conv1.value() convVal = np.array(sess.run(val)) convVal = np.reshape(convVal,[5,5,32]) plt.imshow(convVal[:,:,6]) plt.show()</code></p>
<p>3.8多架构运行<br>&#x2F;&#x2F;GPU使用<br>GPU可以加速深度学习作业的训练速度，如果服务器有多个GPU,那么tensorflow默认使用全部<br>使用部分GPU:</p>
<p>python程序启动时调用：<br><code>CUDA_VISIBLE_DEVICES=0.2.3 python script.py</code></p>
<p>python代码内进行调用：<br><code>import os os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;]=&quot;1&quot;</code></p>
<p>&#x2F;&#x2F;配置GPU显存<br>某些情况下，多作业或者共享GPU的场景中，可以控制tf使用GPU显存大小<br><code>gpuOptions = tf.GPUOptions(per_process_gpu_memory_fraction=0.8) sess = tf.Session(config=tf.ConfigProto(gpu_options=gpuOptions))</code></p>
<p>&#x2F;&#x2F;GPU运行代码<br>#将变量的定义和分配定义到GPU上进行<br><code>with tf.device(&#39;/gpu:0&#39;):     W = tf.get_variable(&#39;W&#39;,(in_dim,out_dim),dtype=tf.float32,initializer=tf.truncated_normal_initializer(stddev=0.1))     b = tf.get_variable(&#39;b&#39;),[out_dim],dtype=tf.float32,initializer=tf.constant_initializer(0))     net = tf.matmul(input_tensor,W)+b</code><br>#在CPU上计算激活函数<br><code>with tf.device(&#39;/cpu:0&#39;):     net = tf.nn.sigmoid(net)</code></p>
<p>&#x2F;&#x2F;多CPU使用，多设备计算<br>&#x2F;&#x2F;利用标号简单的区分并运行<br>#在CPU0上计算<br><code>with tf.device(&#39;/cpu:0&#39;)     ...     net = tf.nn.sigmoid(net)</code><br>#在CPU1上计算<br><code>with tf.device(&#39;/cpu:1&#39;)     ...     net = tf.nn.sigmoid(net)</code></p>
<p>&#x2F;&#x2F;在集群上运行，需要在多个主机上准备多份代码，代码前面部分相同，后续有所不同<br>&#x2F;&#x2F;定义多主机运行参数<br>#这里的地址形式为IP:Port<br><code>cluster = tf.train.ClusterSpectf.train.ClusterSpec(&#123;     &quot;worker&quot;:[         &quot;xx.xx.xx.xx:2222&quot;,    #/job:worker/task:0         &quot;xx.xx.xx.xx:2222&quot;,    #这里job的名称为自定义         &quot;xx.xx.xx.xx:2222&quot;    #task编号同样需在Server中定义         ],     &quot;ps&quot;:[         &quot;xx.xx.xx.xx:2222&quot;,         &quot;xx.xx.xx.xx:2222&quot;         ]&#125;) server = tf.train.Server(cluster, job_name=&quot;worker&quot;, task_index=0)</code></p>
<p>&#x2F;&#x2F;定义第二个主机参数<br>#这里的地址形式为IP:Port<br><code>cluster = tf.train.ClusterSpectf.train.ClusterSpec(&#123;     &quot;worker&quot;:[         &quot;xx.xx.xx.xx:2222&quot;,    #/job:worker/task:0         &quot;xx.xx.xx.xx:2222&quot;,    #这里job的名称为自定义         &quot;xx.xx.xx.xx:2222&quot;    #task编号同样需在Server中定义         ],     &quot;ps&quot;:[         &quot;xx.xx.xx.xx:2222&quot;,         &quot;xx.xx.xx.xx:2222&quot;         ]&#125;) server = tf.train.Server(cluster, job_name=&quot;worker&quot;, task_index=1)</code></p>
<p>&#x2F;&#x2F;不同设备的运行代码<br><code>with tf.device(&#39;/job:worker/task:0/cpu:0&#39;):     ...</code></p>
<p>&#x2F;&#x2F;将不同的任务分配到不同的计算节点上<br>&#x2F;&#x2F;分配计算任务<br><code>with tf.device(tf.train.replica_device_setter(     worker_device=&quot;/job:worker/task:%d&quot; %task_index,cluster=cluster)</code></p>
<p>&#x2F;&#x2F;函数replica_device_setter会将变量参数的定义部分自动定义到ps服务中，后续需要定义Session,用于执行这个过程<br>&#x2F;&#x2F;多主机运行<br>#定义句柄，迭代多少步后停止迭代<br><code>hooks = [tf.train.StopAtStepHook(last_step=1000000)]</code><br>#MonitoredTrainingSession函数会完成会话初始化工作<br>#保存checkpoint,恢复checkpoint,异常判断等<br>#这里需要定义master主机，定义保存、控制操作的master<br><code>with tf.train.MonitroedTrainingSession(     master=server.target,     is_chief=(task_index==0),     checkpoint_dir=&quot;dir/to/cp&quot;,     hooks=hooks) as mon_sess:     ...</code></p>
<p>注：在程序运行过程中，需要认为将程序分配到各个主机上，依次运行各个主机</p>
<p>&#x2F;&#x2F;队列用于数据读取和处理，队列可以是先进先出队列，也可以是随机队列，用于随机化输出<br>&#x2F;&#x2F;tf中队列的操作是对于训练前的过程而言的，有以下作用<br>1.多线程数据预处理并将其推入队列<br>2.在执行过程中，队列不断提供训练数据<br>&#x2F;&#x2F;简单实例说明队列使用<br><code>def simple_shuffle_batch(source,capacity,batch_size=10):</code><br>    #定义随机序列<br>    <code>queue = tf.RandomShuffleQueue(         capacity=capacity,         min_after_dequeue=int(0.9*capacity),         shapes=source.shape,         dtypes=source.dtype)</code><br>    #定义enqueue过程<br>    <code>enqueue = queue.enqueue(source)</code><br>    #定义执行进程个数<br>    <code>num_threads = 4     qr = tf.train.QueueRunner(queue,[enqueue]*num_threads)</code><br>    #声明Queue runner,使得其可以被执行<br>    <code>tf.train.add_queue_runner(qr)</code><br>    #获取数据<br>    <code>return queue.dequeue_many(batch_size)</code><br>#产生测试数据<br><code>input = tf.constant(list(range(100))) input = tf.data.Dataset.from_tensor_slices(input) input = input.make_one_shot_iterator().get_next()</code></p>
<p>#定义函数<br><code>get_batch = simple_shuffle_batch(input,capacity=20)</code></p>
<p>#定义session<br><code>with tf.train.MonitoredSession() as sess:     while not sess.should_stop():         print(sess.run(get_batch))</code></p>
<p>注：队列操作可以使得数据读取过程得到并行的优化，这对于提升程序的运行速度是很有利的。</p>
<p>&#x2F;&#x2F;tf相关扩展<br>4.2.1 tf Layers<br>&#x2F;&#x2F;全连接网络<br>#layers定义全连接网络<br><code>net = tf.layers.dense(inputs=net, units=units, activation=tf.nn.relu)</code></p>
<p>#卷积网络<br><code>net = tf.layers.conv2d(     inputs=net, #输入     filters=n_features, #输出特征数     kernel-size=[5, 5], #卷积核心大小     padding=&quot;same&quot;, #边界     activation=tf.nn.relu #激活函数     )</code></p>
<p>&#x2F;&#x2F;前馈神经网络函数<br>#二维最大池化<br><code>net = tf.layers.max_pooling2d(...)</code><br>#二维平均池化<br><code>net = tf.layers.average_pooling2d(...)</code><br>#二维卷积<br><code>net = tf.layers.conv2d(...)</code><br>#dropout<br><code>net = tf.layers.dropout(...)</code><br>#展开<br><code>net = tf.layers.flatten(...)</code><br>#BN<br><code>net = tf.layers.batch_normalization(...)</code></p>
<p>4.2.2 tf Slim<br>#卷积函数<br><code>def conv2d_layer(input_tensor, size=1, feature=128, name=&#39;conv1d&#39;):     with tf.variable_scope(name):         shape = input_tensor.get_shape.as_list()         kernel = tf.get_variable(&#39;kernel&#39;, (size, size, shape[-1], feature), dtype=tf.float32, initializer=tf.truncated_normal_initializer(stddev=0.1))         b = tf.get_variable(&#39;b&#39;, [feature], dtype=tf.float32, initializer=tf.constant_initializer(0))         out = tf.nn.conv2d(input_tensor, kernel, strides=[1,2,2,1],padding=&#39;SAME&#39;)+b     return tf.nn.relu(out)</code><br>#全连接函数<br><code>def full_layer(input_tensor, out_dim, name=&#39;full&#39;):     with tf.variable_scope(name):         shape = input_tensor.get_shape.as_list()         W = tf.get_variable(&#39;W&#39;, (shape[1], out_dim), dtype=tf.float32, initializer=tf.truncated_normal_initializer(stddev=0.1))         b = tf.get_variabel(&#39;b&#39;, [out_dim], dtype=tf.float32, initializer=tf.constant_initializer(0))         out = tf.matmul(input_tensor, W)+b     return out</code></p>
<p>&#x2F;&#x2F;slim实现卷积，tfv2取消该库<br>#引入slim库<br><code>import tensorflow.contrib.slim as slim</code><br>#定义卷积层<br><code>net = slim.conv2d(inputs, 16, 4, strides=2, activation_fn=tf.nn.relu, scope=&#39;conv1&#39;)</code><br>#加入池化层<br><code>net = tf.nn.max_pool(net, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding=&#39;SAME&#39;)</code></p>
<p><code>net = slim.conv2d(net, 32, 4, strides=2, activation_fn=tf.nn.relu, scope=&#39;conv2&#39;) net = tf.nn.max_pool(net, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding=&#39;SAME&#39;)</code></p>
<p>#flatten层，用于将三维的图形数据展开成一维数据，用于全连接层<br><code>net = slim.flatten(net)</code><br>#全连接层<br><code>y = slim.fully_connected(net, 10, activation_fn=line, scope=&#39;full&#39;, reuse=False)</code></p>
<p>4.2.3 tfLearn<br>&#x2F;&#x2F;tflearn抽象层次更高，代码可读性更好,其是一个完整的生态<br>&#x2F;&#x2F;基础网络架构<br>#全连接<br><code>net = tflearn.fully_connected(...)</code><br>#卷积<br><code>net = tflearn.conv_2d(...)</code><br>#LSTM<br><code>net = tflearn.lstm(...)</code><br>#dropout<br><code>net = tflearn.dropout(...)</code></p>
<p>&#x2F;&#x2F;输入函数<br><code>network = tflearn.input_data(shape=[None, 28, 28, 1], name=&#39;input&#39;)</code></p>
<p>&#x2F;&#x2F;优化部分<br>#定义优化过程<br><code>network = tflearn.layers.estimator.regression(     network,     optimizer=&#39;adam&#39;, #优化方法     learning_rate=0.01, #学习率     loss=&#39;categorical_crossentropy&#39;, #损失函数     name=&#39;target&#39;)</code></p>
<p>&#x2F;&#x2F;利用tflearn完成手写数字的识别任务<br><code>import tflearn from tflearn.layers.core import input_data,dropout, fully_connected from tflearn.layers.conv import conv_2d, , max_pool_2d from tflearn.layers.normalization import local_response_normalization from tflearn.layers.estimator import regression</code></p>
<p>#载入并处理数据<br><code>import tflearn.datasets.mnist as mnist X, Y, testX, testY = mnist.load_data(one_hot=True)</code><br>#转换为二维图形<br><code>X = X.reshape([-1, 28, 28, 1]) testX = testX.reshape([-1, 28, 28, 1])</code></p>
<p>#建立神经网络<br><code>network = tflearn.input_data(shape=[None, 28, 28, 1], name=&#39;input&#39;) network = conv_2d(network, 32, 3, activation=&#39;relu&#39;, regularizer=&#39;L2&#39;) network = max_pool_2d(network) network = local_response_normalization(network) network = fully_connected(network, 128, activation=&#39;tanh&#39;) network = dropout(network, 0.8) network = fully_connected(network, 256, activation=&#39;tanh&#39;) network = dropout(network, 0.8) network = fully_connected(network, 10, activation=&#39;softmax&#39;)</code></p>
<p>#定义优化过程<br><code>network = regression(     network,     optimizer=&#39;adam&#39;,     learning_rate=0.01,     loss=&#39;categorical_crossentropy&#39;,     name=&#39;target&#39;)</code></p>
<p>#训练过程<br><code>model = tflearn.DNN(network, tensorboard_verbose=0) model.fit(&#123;&#39;input&#39;:X&#125;, &#123;&#39;target&#39;:Y&#125;, n_epoch=20,     validation_set=(&#123;&#39;input&#39;:testX&#125;, &#123;&#39;target&#39;:testY&#125;),     snapshot_step=100, show_metric=True, run_id=&#39;convnet_mnist&#39;)</code></p>
<p>&#x2F;&#x2F;Keras代码可读性好，并且横跨多个机器学习框架，但其扩展性较差<br>&#x2F;&#x2F;引入库<br><code>from keras.layers import Dense, Dropout, Flatten from keras.layers import Conv2D, MaxPooling2D</code></p>
<p>&#x2F;&#x2F;Keras直接顺序加入模型，无需通过数据方式进行传递<br>&#x2F;&#x2F;基础网络层<br><code>from keras.models import Sequential model = Sequential()</code><br>#加入卷积层<br><code>model.add(Conv2D(...))</code><br>#加入池化层<br><code>model.add(MaxPooling2D(...))</code><br>#加入全连接层<br><code>model.add(Dense(...))</code><br>#dropout<br><code>model.add(Dropout(0.25))</code></p>
<p>&#x2F;&#x2F;定义model后可直接加入多种层进行操作，同样其需要定义训练函数<br>&#x2F;&#x2F;定义优化过程<br><code>from keras.optimizers import SGD</code><br>#定义迭代算法<br><code>sgd = SGD(lr=0.01, decay=1e-6, momentum=0.9, nesterov=True) model.compile(loss=&#39;categorical_crossentropy&#39;, optimizer=sgd)</code><br>#训练过程<br><code>model.fit(x_train, y_train, batch_szie=32, epochs=10)</code><br>#评估训练效果<br><code>score = model.evaluate(x_test, y_test, batch_size=32)</code></p>
<p>&#x2F;&#x2F;完整代码<br><code>import keras from keras.models import Sequential from keras.layers import Dense, Dropout, Flatten from keras.layers import Conv2D, MaxPooling2D from keras.optimizers import SGD</code></p>
<p>#这里utils为自己定义的库函数，用于载入数据<br><code>import utils X, Y, testX, testY = utils.load_data(one_hot=True) model = Sequential()</code><br>#定义神经网络过程<br><code>model.add(Conv2D(32, (3, 3), activation=&#39;relu&#39;, input_shape=(100, 100, 3))) model.add(Conv2D(32, (3, 3), activation=&#39;relu&#39;)) model.add(MaxPooling2D(pool_size=(2, 2))) model.add(Dropout(0.25))</code></p>
<p><code>model.add(Conv2D(64, (3, 3), activation=&#39;relu&#39;)) model.add(Conv2D(64, (3, 3), activatin=&#39;relu&#39;)) model.add(MaxPooling2D(pool_size=(2, 2))) model.add(Dropout(0.25))</code></p>
<p>#展开为一维数据用于全连接层<br><code>model.add(Flatten()) model.add(Dense(256, activation=&#39;relu&#39;)) model.add(Dropout(0.5)) model.add(Dense(10, activation=&#39;softmax&#39;))</code><br>#梯度迭代算法<br><code>sgd = SGD(lr=0.01, decay=1e-6, momentum=0.9, nesterov=True) model.compile(loss=&#39;categorical_crossentropy&#39;, optimizer=sgd)</code><br>#训练过程<br><code>model.fit(x_train, y_train, batch_size=32, epochs=10)</code><br>#效果评估<br><code>score = model.evaluate(x_test, y_test, batch_size=32)</code></p>
<p>4.3 Tensorboard与问题监控<br>&#x2F;&#x2F;tensorboard最重要的作用就在于观察训练过程中的各种问题并改善，包括梯度消失、过拟合等问题<br>&#x2F;&#x2F;获取所有可训练的参数<br><code>var_list_w = [var for var in tf.trainable_variables() if &#39;w&#39; in var.name] var_list_b = [var for var in tf.trainable_variables() if &#39;b&#39; in var.name]</code></p>
<p>&#x2F;&#x2F;利用定义的梯度算法来计算梯度<br><code>gradient_w = optimizer.compute_gradients(loss, var_list=var_list_w) gradient_b = optimizer.compute_gradients(loss, var_list=var_list_b)</code></p>
<p>&#x2F;&#x2F;返回的梯度是一个列表，可对其进行各种列表操作<br>&#x2F;&#x2F;加入summary操作<br><code>for idx, itr_g in enumerate(gradient_w):     variable_summaries(itr_g[0], &#39;layer%d-w-grad&#39;%idx) for idx, itr_g in enumerate(gradient_b):     variable_summaries(itr_g[0], &#39;layer%d-b-grad&#39;%idx</code></p>
<p><code>for idx, itr_g in enumerate(var_list_w):     variable_summaries(itr_g, &#39;layer%d-w-grad&#39;%idx) for idx, itr_g in enumerate(var_list_b):     variable_summaries(itr_g, &#39;layer%d-b-grad&#39;%idx)</code></p>
<p>4.4改善深度神经网络<br>&#x2F;&#x2F;出现梯度消失一种最有效的方式就是进行BN操作<br>&#x2F;&#x2F;batchnorm层<br><code>net = tf.contrib.layers.batch_norm(net)</code></p>
<p>&#x2F;&#x2F;加入BN层的神经网络<br>#对于sigmoid激活函数来讲，BN操作效果可能不理想<br><code>net = slim.fully_connected(x, 4, activation_fn=tf.nn.sigmoid, scope=&#39;full1&#39;, reuse=False) net = tf.contrib.layers.batch_norm(net)</code></p>
<p><code>net = slim.fully_connected(net, 8, activation_fn=tf.nn.sigmoid, scope=&#39;full2&#39;, reuse=False) net = tf.contrib.layers.batch_norm(net)</code></p>
<p><code>net = slim.fully_connected(net, 8, activation_fn=tf.nn.sigmoid, scope=&#39;full3&#39;, reuse=False) net = tf.contrib.layers.batch_norm(net)</code></p>
<p><code>net = slim.fully_connected(net, 4, activation_fn=tf.nn.sigmoid, scope=&#39;full4&#39;, reuse=False) net = tf.contrib.layers.batch_norm(net)</code></p>
<p><code>net = slim.fully_connected(net, 3, activation_fn=tf.nn.sigmoid, scope=&#39;full5&#39;, reuse=False)</code></p>
<p><code>loss = tf.reduce_mean(tf.square(y-label))</code></p>
<p>4.5性能优化建议<br>&#x2F;&#x2F;训练前的优化技巧<br>1.网络结构优化<br>Relu和BN能够有效加快神经网络训练速度<br>卷积核心的选取可以从大的卷积核心修改为多个小的卷积核心<br>将nxn修改为nx1+1xn，减少参数量，不同的输出内容之间可以进行concat<br>引入跨层支路解决梯度问题（ResNet)<br>2.初始值的选取<br>不好的初始值对训练的影响非常大，有效的初始化方法包括xavier初始化方法和He初始化方法<br>3.数据预处理<br>包括去均值和方差均衡<br>&#x2F;&#x2F;训练过程中的优化技巧<br>1）优化算法的选择<br>Adam<br>2）学习率的选取<br>从大的步长开始进行迭代，逐步减少学习率<br>3）Batchsize选择<br>4）model ensembles<br>使用不同初始值同时训练多个模型，预测过程中将多个模型输出结果做平均，有效提升结果精度<br>5)dropout选择<br>从0.5附近进行调整，调整步长为0.05左右</p>
<p>&#x2F;&#x2F;物体检测<br>1.传统检测方法<br>2001年，基于Haar特征和Adaboost检测方法引起轰动<br>2012年之前，三方面不断创新与优化：特征的设计更新、检测窗口的选择、分类器的设计更新</p>
<p>2.深度学习的物体检测<br>1）基于分类的物体检测<br>处理过程：图像被分解成多个小区域，每个小区域将运行一个分类算法以确定区域是否包含待检测物体，之后再在这个小区域的周围确认物体的边界框。代表算法：R-CNN、Fast-RCNN、Faster-RCNN<br>2) 基于回归的物体检测<br>将问题建模为回归问题，通过深度神经网络直接预测出边界框和所属类别的置信度。代表算法：SSD、YOLO模型</p>
<p>&#x2F;&#x2F;YOLO模型<br>官网：<a href="https://pjreddie.com/darknet/yolo/">https://pjreddie.com/darknet/yolo/</a><br>&#x2F;&#x2F;选讲tiny YOLO v1模型，由9个卷积层和3个全连接层组成，每个卷积层都由卷积层、LeakyRelu和Max Pooling操作组成，前9个卷积层可被理解为特征提取器，最后三个全连接层可被理解为预测边界框的回归器。<br>参考论文：You Only Look Once:Unified, Real-Time Object Detection<br>参考实例：<a href="https://github.com/xslittlegrass/CarND-Vehicle-Detection">https://github.com/xslittlegrass/CarND-Vehicle-Detection</a><br>模型参数：45089374<br>深度学习框架：Keras 1.2.2</p>
<p>&#x2F;&#x2F;构建YOLO模型网络结构<br><code>import keras from keras.models import Sequential from keras.layers.convolutional import Convlution2D, MaxPooling2D from keras.layers.advanced_activations import LeakyReLU from keras.layers.core import Flatten, Dense, Activation, Reshape from utils import load_weights, Box, yolo_net_out_to_car_boxes, draw_box def construct_yolo_model():     keras.backend.set_image_dim_ordering(&#39;th&#39;)     model = Sequential()     model.add(Convolution2D(16, 3, 3, input_shape=(3, 448, 448), border_mode=&#39;same&#39;, subsample=(1, 1)))     model.add(LeakyReLU(alpha=0.1))     model.add(MaxPooling2D(pool_size=(2, 2)))</code></p>
<pre><code>model.add(Convolution2D(32, 3, 3, border_mode=&#39;same&#39;))
model.add(LeakyReLU(alpha=0.1))
model.add(MaxPooling2D(pool_size=(2, 2), border_mode=&#39;valid&#39;))

model.add(Convolution2D(32, 3, 3, border_mode=&#39;same&#39;))
model.add(LeakyReLU(alpha=0.1))
model.add(MaxPooling2D(pool_size=(2, 2), border_mode=&#39;valid&#39;))

model.add(Convolution2D(64, 3, 3, border_mode=&#39;same&#39;))
model.add(LeakyReLU(alpha=0.1))
model.add(MaxPooling2D(pool_size=(2, 2), border_mode=&#39;valid&#39;))

model.add(Convolution2D(128, 3, 3, border_mode=&#39;same&#39;))
model.add(LeakyReLU(alpha=0.1))
model.add(MaxPooling2D(pool_size=(2, 2), border_mode=&#39;valid&#39;))

model.add(Convolution2D(256, 3, 3, border_mode=&#39;same&#39;))
model.add(LeakyReLU(alpha=0.1))
model.add(MaxPooling2D(pool_size=(2, 2), border_mode=&#39;valid&#39;))

model.add(Convolution2D(512, 3, 3, border_mode=&#39;same&#39;))
model.add(LeakyReLU(alpha=0.1))
model.add(MaxPooling2D(pool_size=(2, 2), border_mode=&#39;valid&#39;))

model.add(Convolution2D(1024, 3, 3, border_mode=&#39;same&#39;))
model.add(LeakyReLU(alpha=0.1))

model.add(Convolution2D(1024, 3, 3, border_mode=&#39;same&#39;))
model.add(LeakyReLU(alpha=0.1))

model.add(Convolution2D(1024, 3, 3, border_mode=&#39;same&#39;))
model.add(LeakyReLU(alpha=0.1

model.add(Flatten())
model.add(Dense(256))
model.add(Dense(4096))
model.add(LeakyReLU(alpha=0.1))
model.add(Dense(1470))
model.summary()
return model
</code></pre>
<p>注：网络的输入是形状为（3,448,448)的图像，其输出是一个1470维度的向量，它包含预测边界框、物体类别信息。1470矢量被分成三个部分，分别给出了所属类别概率、置信度和边框坐标。这三个部分进一步划分为49个小区域，与每个单元的预测相对应。<br>输出向量信息组织方式：<br><code>probability:49*20=980</code><br>判断类别，20个类别<br><code>confidence:49*2=98</code><br>是否包含物体（0,1）<br><code>box coordinates:49*8=392 (x_min,y_min,x_max,y_max),(c_x,c_y,w,h)</code></p>
<p>8.4.3车辆图像数据探索<br>1.车辆视频数据预处理<br>&#x2F;&#x2F;预处理及可视化图像<br><code>def visualize_images():     imagePath = &#39;./test_images/test1.jpg&#39;     image = plt.imread(imagePath)</code><br>    #去除顶部和底部图片<br>    <code>image_crop = image[300:650,500:,:]</code><br>    #将图片转换为模型所需要的输入格式<br>    <code>resized = cv2.resize(image_crop, (448, 448))     f1,(ax11,ax22,ax33) = plt.subplot(1, 3, figsize=(16, 6))     ax11.imshow(image)     ax22.imshow(image_crop)     ax33.imshow(resized)     pylab.show()     return resized</code></p>
<p>8.4.5迁移学习<br>通过迁移学习加载使用Pre-trained YOLO模型进行行车检测。具体做法是将pre-trained模型中的权重加载进之前构造的模型结构中，官网提供的权重，可以通过脚本解析成Keras能够加载的格式。<br>&#x2F;&#x2F;加载YOLO模型权重<br><code>def load_model_weights(model):     #预训练权重网址：https://pjreddie.com/darknet/yolo/     load_weights(model, &#39;./yolo-tiny.weights&#39;)</code></p>
<p>&#x2F;&#x2F;加载模型权重的具体逻辑<br><code>def load_weights(model, yolo_weight_file):     data = np.fromfile(yolo_weight_file, np.float32)     data = data[4:]     index = 0     for layer in model.layers:         shape = [w.shape for w in layer.get_weights()]         if shape !=[]:             kshape, bshape = shape             bia = data[index:index+np.prod(bshape)].reshape(bshape)             index += np.prod(bshape)             ker = data[index:index:index+np.prod(kshape)].reshape(kshape)             index += np.prod(kshape)             layer.set_weights([ker, bia])</code></p>
<p>&#x2F;&#x2F;模型推断<br>&#x2F;&#x2F;使用模型进行在线推断，预测出车辆区域<br><code>def inference_image(model, resized):     #转置     batch = np.transpose(resized, (2, 0, 1))     #将像素值变换到-1~1     batch = 2*(batch/255.) - 1     #将一张图片转为数组     batch = np.expand_dims(batch, axis=0）     out = model.predict(batch)     return out</code></p>
<p>&#x2F;&#x2F;绘制检测结果<br>&#x2F;&#x2F;将上述的预测结果转换为边框坐标，同时基于阈值进行预测<br><code>th = 0.17 boxes = yolo_net_to_out_to_car_boxes(out[0], threshold=th)</code></p>
<p>&#x2F;&#x2F;定义box边框对象，判断是否保留预测的边框结果通过c,在图像上绘制车辆位置通过对象中的坐标信息<br>#定义box类，存储边框信息和物体检测类别等信息<br><code>class Box: def __init__(self):     #x, y轴坐标     self.x, self.y = float(), float()     #边框宽度和长度     self.w, self.h = float(), float()     #置信度     self.c = float()     #所属类别概率     self.prob = float()</code></p>
<p>&#x2F;&#x2F;通过yolo_net_to_out_to_car_boxes方法，将预测出的Vector转换为Box对象信息。其核心逻辑是解析模型预测输出向量中的坐标、类别和置信度信息<br>&#x2F;&#x2F;置信度大于阈值边界框则进行保留<br><code>class_num = 6 #yolo模型可以预测多种类别，6为车辆所属类别 p = probs[grid, :] *bx.c if p[class_num]&gt;=threshold:     bx.prob = p[class_num]     boxes.append(bx)</code></p>
<p>&#x2F;&#x2F;将结果绘制在图像上<br><code>def visualize_image_car_detection(boxes):     imagePath = &#39;./test_images/test1.jpg&#39;     image = plt.imread(imagePath)     f, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))     ax1.imshow(image)     ax2.imshow(draw_box(boxes, plt.imread(imagePath), [[500, 1280],[300,650]]))     pylab.show()</code></p>
<p>&#x2F;&#x2F;将边框绘制在图像上<br><code>def draw_box(boxes, im, crop_dim):     imgcv = im     [xmin, xmax] = crop_dim[0]     [ymin, ymax] = crop_dim[1]     for b in boxes:         h, w, _ = imgcv.shape         left = int((b.x-b.w/2.)*w)         right = int((b.x+b.w/2.)*w)         top = int((b.y-b.h/2.)*h)         bot = int((b.y+b.h/2.)*h)         left = int(left*(xmax-xmin)/w+xmin)         right = int(right*(xmax-xmin)/w+xmin)         top = int(top*(ymax-ymin)/h+ymin)         bot = int(bot*(ymax-ymin)/h+ymin)         if left&lt;0 : left=0         if right&gt;w-1 : right=w-1         if top&lt;0 : top=0         if bot&gt;h-1 : bot=h-1         thick = int((h+w)//150)         cv2.rectangle(imgcv, (left, top), (right, bot), (255,0,0), thick)     return imgcv</code></p>
<p>8.5.1英伟达End to End模型<br>End to End的好处：通过缩减人工预处理和后续处理，尽可能使模型从原始输入到输出，使得其根据网络模型能够有足够多的空间进行自动调节，从而减少基于规则的复杂变化。<br>缺点：可解释性较差，准确度和精度不容易受控制。<br>&#x2F;&#x2F;构建英伟达模型<br><code>import tensorflow as tf import keras from keras.models import Sequential from keras.layers import Dense, Activation, Flatten, Lambda from keras.layers import Conv2D, Dropout from keras import losses def nvida_model():     model = Sequential()     model.add(Lambda(lambda x: x/127.5-1., input_shape=(img_height, img_width, img_channels)))     model.add(Conv2D(24, kernel_size=(5, 5), strides=(2, 2), padding=&#39;valid&#39;, kernel_initializer=&#39;he_normal&#39;, activation=&#39;elu&#39;))     model.add(Conv2D(36, kernel_size=(5, 5), strides=(2, 2), padding=&#39;valid&#39;, kernel_initializer=&#39;he_normal&#39;, activation=&#39;elu&#39;))     model.add(Conv2D(48, kernel_size=(5, 5), strides=(2, 2), padding=&#39;valid&#39;, kernel_initializer=&#39;he_normal&#39;, activation=&#39;elu&#39;))     model.add(Conv2D(64, kernel_size=(5, 5), strides=(2, 2), padding=&#39;valid&#39;, kernel_initializer=&#39;he_normal&#39;, activation=&#39;elu&#39;))     model.add(Conv2D(64, kernel_size=(5, 5), strides=(2, 2), padding=&#39;valid&#39;, kernel_initializer=&#39;he_normal&#39;, activation=&#39;elu     model.add(Flatten())     model.add(Dense(1164, kernel_initializer=&#39;he_normal&#39;, activation=&#39;elu&#39;))     model.add(Dense(100, kernel_initializer=&#39;he_normal&#39;, activation=&#39;elu&#39;))     model.add(Dense(50, kernel_initializer=&#39;he_normal&#39;, activation=&#39;elu&#39;))     model.add(Dense(10, kernel_initializer=&#39;he_normal&#39;, activation=&#39;elu&#39;))     model.add(Dense(1, kernel_initializer=&#39;he_normal&#39;))     model.compile(loss=&#39;mse&#39;, optimizer=&#39;Adadelta&#39;)     return model</code></p>
<p>&#x2F;&#x2F;8.5.3数据分析<br>1）转向控制数据分布<br>#绘制转向分布<br><code>def steering_distribution():     wheel_sig = pd.read_csv(params.data_dir+&#39;/epoch01_steering.csv&#39;)     wheel_sig.head() wheel_sig.wheel.hist(bins=50)</code></p>
<p>2)数据变化幅度<br>#绘制转向变化幅度<br><code>def angel_visualize():     wheel_sig = pd.read_csv(params.data_dir+&#39;/epoch01_steering.csv&#39;)     wheel_sig.plot(x=&#39;frame&#39;, y=&#39;wheel&#39;)     plt.show()</code></p>
<p>8.5.4读入视频，并处理图像<br>&#x2F;&#x2F;使用OpenCV从视频中提取图像，以及与其对应的转向角度并返回<br>#提取图像并处理<br><code>imgs = [] wheels = [] epochs = [10] for epoch in epochs:     vid_path = utils.join_dir(params.data_dir, &#39;epoch&#123;:0&gt;2&#125;_front.mp4&#39;.format(epoch))     assert os.path.isfile(vid_path)     frame_count = frame_count_func(vid_path)     cap = cv2.VideoCapture(vid_path)     for frame_id in range(frame_count):         while True:         #通过OpenCV中的VideoCapture进行视频中图像的提取             ret, img = cap.read()             if not ret:                 break             #用户可以自定义对图像的处理、扩展和增强操作             img = a_image_convert.img_preprocess(img, color_mode, flip=False)             imgs.append(img)         csv.path = os.path.join(data_dir, &#39;epoch&#123;:0&gt;2&#125;_steering.csv&#39;.format(epoch))         rows = pd.read_csv(csv.path)         yy = rows[&#39;wheel&#39;].values         wheels.extend(yy)         cap.release()     imgs = np.array(imgs)     wheels = np.array(wheels)     wheels = np.reshape(wheels, (len(wheels), 1)     return imgs, wheels</code></p>
<p>8.5.5深度学习模型构建与训练<br>&#x2F;&#x2F;训练模型<br><code>def training(model, X_train_RGB, y_train_RGB):     RGB_model = model     time_start = time.time()     #fit the model     RGB_history = RGB_model.fit(X_train_RGB, y_train_RGB, epochs=30, batch_size=batch_size)     return RGB_model, RGB_history</code></p>
<p>&#x2F;&#x2F;可视化结果<br>#将训练过程中的loss误差进行可视化<br><code>def visualize_label(RGB_history):     print(RGB_history.history[&#39;loss&#39;]     plt.figure(figsize=(9, 6))     plt.plot(RGB_history.history[&#39;loss&#39;])     plt.title(&#39;model loss&#39;)     plt.ylabel(&#39;Loss&#39;, fontsize=12)     plt.xlabel(&#39;Epoch&#39;, fontsize=12)     plt.legend([&#39;train RGB&#39;], loc=&#39;upper right&#39;)     plt.grid()     plt.show()</code></p>
<p>&#x2F;&#x2F;可视化<br>&#x2F;&#x2F;数据的绘图过程就是将前面所得到的一系列数据，通过静态、动态的二维、三维图形进行展示<br>1.Matplotlib<br>&#x2F;&#x2F;绘制y&#x3D;sinx图像<br><code>import numpy as np import matplotlib.pyplot as plt x = np.linspace(0, 4*np.pi, 1000) y = np.sin(x) plt.plot(x,y)</code></p>
<p>&#x2F;&#x2F;利用API,绘制更加审美要求的图像<br><code>import numpy as np import matplotlib.pyplot as plt import matplotlib as mpl #设置图片风格 mpl.style.use(&#39;seaborn-darkgrid&#39;) #定义曲线 x = np.linspace(0, 4*np.pi, 100) y1 = np.sin(x) y2 = np.sin(x+1) y3 = np.sin(x+2) #绘图 plt.plot(x, y1, color=&#39;#009900&#39;, lw=6, alpha=0.6) plt.plot(x, y2, color=&#39;#990000&#39;, lw=6, alpha=0.6) plt.plot(x, y3, color=&#39;#000099&#39;, lw=6, alpha=0.6) #展示 plt.show()</code></p>
<p>9.4ECharts<br>&#x2F;&#x2F;ECharts提供了常规的折线图、柱状图、散点图、饼图、K线图等等，功能强大。<br>&#x2F;&#x2F;ECharts图形绘制<br>略</p>
<p>&#x2F;&#x2F;文本向量化<br>&#x2F;&#x2F;文本向量化函数<br>#文本TfIdf向量化<br><code>from sklearn.feature_extraction.text import TfidfVectorizer vectorizer = TfidVectorizer() vectors = vectorizer.fit_transform(datas)</code></p>
<p>&#x2F;&#x2F;文本向量化的数据进行降维<br>&#x2F;&#x2F;LDA降维<br><code>from sklearn.decomposition import LatentDirichletAllocation lda = LatenDirichletAllocation(n_components=n_topic, max_iter=5,     learning_method = &#39;online&#39;,     learning_offset = 50.,     radom_state = 0)</code><br>#用LDA方法降维数据<br><code>dr_vectors = lad.fit_transform(vectors)</code></p>
<p>9.6三维可视化<br>&#x2F;&#x2F;ECharts地图柱状图<br><code>myChart.setOption(&#123;     visualMap: &#123;         show: flase,         calculable: true,         realtime: false,         inRange: &#123;         color: [&#39;#313695&#39;, &#39;#4575b4&#39;, &#39;#74add1&#39;, &#39;#abd9e9&#39;,                 &#39;#e0f3f8&#39;, &#39;#ffffbf&#39;, &#39;#fee090&#39;, &#39;#fdae61&#39;,                 &#39;#f46d43&#39;, &#39;#d73027&#39;, &#39;#d73027&#39;, &#39;a50026&#39;]                 &#125;,         outOfRange: &#123;             colorAlpha: 0             &#125;,         max: linedata[1]         &#125;,         ...         series: [&#123;             type: &#39;bar3D&#39;,             shading: &#39;realistic&#39;,             coordinateSystem: &#39;mapbox&#39;,             barSize: 0.2,             silent: true,             data: linedata[0]             &#125;]         &#125;);</code></p>
<p>&#x2F;&#x2F;利用Matplotlib完成对三维数据的可视化任务<br><code>from mpl_toolkits.mplot3d import axes3d import matplotlib.pyplot as plt from matplotlib import cm import matplotlib.style as style style.use(&#39;seaborn-darkgrid&#39;)</code></p>
<p>#定义三维画布<br><code>fig = plt.figure() ax = fig.gca(projection=&#39;3d&#39;)</code><br>#获取数据<br><code>X, Y, Z = axes3d.get_test_data(0.05)</code><br>#绘制surface<br><code>ax.plot_surface(X, Y, Z, rstride=8, cstride=8, alpha=0.3)</code><br>#绘制等值线<br><code>cst = ax.contourf(X, Y, Z, zdir=&#39;z&#39;, offset=-100, cmap=cm.coolwarm) cst = ax.contourf(X, Y, Z, zdir=&#39;x&#39;, offset=-40, cmap=cm.coolwarm) cst = ax.contourf(X, Y, Z, zdir=&#39;y&#39;, offset=40, cmap=cm.coolwarm)</code></p>
<p><code>plt.show()</code></p>
<p>9.7动态可视化<br>&#x2F;&#x2F;Matplotlib中用于数据动态演示的方法为animation,其可以通过函数进行简单的调用，以进行动态图形的演示工作<br>&#x2F;&#x2F;动画展示<br><code>import matplotlib.animation as animation animation.FuncAniamtion(     ...     )</code></p>
<p>&#x2F;&#x2F;动态可视化的展示方式是在普通的图表之上通过不断地修改数据并进行展示，这种修改可以通过setOption而得到的，在实现上可以通过函数递归的方式实现动态数据的可视化工作<br><code>function update()&#123;     myChart.setOption(...);         setTimeout(update, UPDATE_DURATION);         &#125; update();</code></p>
<p>&#x2F;&#x2F;优化实践<br>10.1通用深度神经网络训练优化建议</p>
<p>1）通用的较为优化的训练过程<br>1.将问题转换为相似的经典问题场景，参照paper中的配置和调优技巧进行最初的实验与优化<br>2.优化算法：选用随机梯度下降（SGD)算法，虽然批量梯度下降（BGD)相比SGD有一些优势，但是在处理大规模数据时，SGD及其优化变种更加简单和快速。<br>3.随机Shuffle样本：应尽量避免连续处理的样本属于同一类别的情况。尽量选择当前样本能让模型产生较大的误差，而不是较小的误差<br>4.规范化数据：输入的每个变量均值最好趋近于0.变换输入变量，使其协方差相近，变量间尽量不要相关<br>5.激活函数的选取：相比Sigmoid函数，tanh和Relu有更好的收敛速度。<br>6.权重初始化：可以随机通过一种分布，均值为0.<br>7.选择学习率：每个权重都可以选取属于自己的学习率。处于低层的权重学习率最好大于高层的权重学习率。学习率最好正比于每个单元的输入数量。</p>
<p>2）CNN训练过程中通常关注的优化点和参数<br>一般比较关注：Learning Rate,Weight Decay,Momentum,Batchsize,Init Weights,数据增强<br>eg:在Resnet中，使用SGD优化算法优化方法训练，mini-batch的大小设置为256，学习率初始化为0.1.随着训练进行，当Loss不再下降，会每次自适应以10倍进行缩减学习率。模型训练用了60x10^4轮迭代。Weight Decay设置为0.0001，同时设置momentum为0.9</p>
<p>3)RNN训练过程中通常关注的优化点和参数<br>一般比较关注：SGD,正则化，规范化梯度，Pad Sentence,Init Weight, Batch Size, Embedding输入，输出控制，Vacabulary Size, Sampled Softmax<br>eg:Google发布的TTS模型TACOTRON为例</p>
<p>10.1.1 过拟合和欠拟合<br>欠拟合：若训练集和测试集的误差有收敛但很高时，则为高偏差<br>过拟合：若训练集和测试集的误差较大时，则为高方差</p>
<p>解决过拟合的方法：<br>正则化，数据增强，Early Stop, Dropout, Batch Normalization</p>
<p>解决欠拟合的方法：<br>1.使用更加复杂的深度学习网络架构<br>2.添加其他特征项，有时候模型出现欠拟合的情况是因为特征项不够导致的，可以添加其他特征项来很好的解决这个问题<br>3.减少正则化参数和组件，正则化的目的是用来防止过拟合。</p>
<p>10.1.2数据增强<br>&#x2F;&#x2F;数据增强的根本原因在于机器在学习的过程中会在模型中遇到大量的参数，同时为了防止过拟合<br>1）对于图像数据，可采取：<br>1.图像平移：使得网络学习到平移不变的特性<br>2.图像旋转：使得网络学习到旋转不变的特性<br>3.图像亮度变化<br>4.裁剪<br>5.缩放<br>6.图像模糊:用不同的卷积模板产生模糊图像<br>2）语音识别中对输入数据添加随机噪声等方式<br>3）NLP中最常用的方式就是进行近义词替换等方式<br>4）噪声注入，可以对输入添加噪声，也可以对隐藏层或者输出层添加噪声</p>
<p>10.1.3梯度消失<br>&#x2F;&#x2F;实验数据显示了深度神经网络在训练过程中，随着epoch的增加各隐藏层的学习率变化。前面隐藏层的学习速度要低于后面的隐藏层<br>&#x2F;&#x2F;梯度消失的原因：根据链式法则，如果每一层神经元对上一层输出的偏导乘上权重结果都小于1的话，那么即使这个结果是0.99，在经过足够多层的传播后，误差对输入层的偏导也会趋近于0<br>解决梯度消失的策略：<br>1.BN<br>2.RNN中使用LSTM:适用于RNN,门控制和长时记忆可缓解和解决梯度消失问题<br>3.激活函数Relu:新的激活函数解析性质更好，其在一定程度上克服了sigmoid函数和tanh函数的梯度消失问题。<br>4.在RNN反向传播过程中减少时间步长度。</p>
<p>10.1.4初始化权重<br>&#x2F;&#x2F;在参数解空间内，好的权重初始化方式，意味着离全局最小值更近。<br>1.高斯初始化，为权重初始化较小的值，权重按照高斯分布随机进行初始化，固定均值和方差<br>2.Xaiver更新方法，使用tanh为激活函数，效果较好。进行梯度更新时，收敛速度较快，然而没有考虑Relu<br>3.MSRA方法，适用于从头训练深层深度神经网络的网络结构。权重以高斯分布随机进行初始化，方差需要考虑空间过滤器的大小和过滤器数量的影响。</p>
<p>10.1.5优化算法<br>近些年最常用的是采用Adam优化算法，也可以采用自适应学习率的方法实现快速收敛。</p>
<p>10.1.6超参数选择<br>一些实践经验：<br>1.在验证集上进行调参<br>2.优先调Learning Rate<br>3.通过初期设计卷积层尽量深、卷积核尽量多的模型，强行让模型拟合训练集，这时会出现过拟合，之后通过Dropout、正则化和Data Augument等等方式去改善模型结果<br>4.调整模型的层数和卷积核数量</p>
<p>&#x2F;&#x2F;通过Scikit-learn的网格搜索库进行参数调优实例<br>1.常见搜索参数<br>学习率、Dropout、Epochs和神经元数量<br>2.数据集下载<br>数据集为Pima Indians Onset of Diabetes分类数据集<br>下载地址：<a href="https://archive.ics.uci.edu/ml/machine-learning-databases/pima-indians-diabetes/">https://archive.ics.uci.edu/ml/machine-learning-databases/pima-indians-diabetes/</a><br>3.搜索最优batchsize和epochs<br>&#x2F;&#x2F;以20的步长，从10到100逐步评估不同的微型批尺寸，epochs分别设置为10、50、100<br><code>import numpy from sklearn.grida_search import GridSearchCV from keras.models import Sequential from keras.layers import Dense from keras.wrappers.scikit_learn import KerasClassifier</code></p>
<p>#Function to create model, required for KerasClassifier<br><code>def create_model():     #create model     model = Sequential()     model.add(Dense(12, input_dim=8, activation=&#39;relu&#39;))     model.add(Dense(1, activation=&#39;sigmoid&#39;))</code></p>
<pre><code>#compile model
model.compile(loss=&#39;binary_crossentropy&#39;, optimizer=&#39;adam&#39;, metrics=[&#39;accuracy&#39;])
return model
</code></pre>
<p><code>#fix random seed for reproducibility seed = 7 numpy.random.seed(seed) #load dataset dataset = numpy.loadtxt(&quot;pima-indians-diabetes.csv&quot;, delimiter=&#39;,&#39;) #split into input (x) and output (Y) variables X = [:, 0:8] Y = [:, 8] #create model model = KerasClassifier(build_fn=create_model, verbose=0) #define the grid search parameters batch_size = [10, 20, 40, 60, 80, 100] epochs = [10, 50, 100] param_grid = dict(batch_size=batch_size, nb_epoch=epochs) grid = GridSearchCV(estimator=model, param_grid=parm_grid, n_jobs=-1) grid_result = grid_fit(X,Y) #summarize results print(&quot;Best: %f using %s&quot; % (grid_result.best_score_, grid_result.best_params)) for params, mean_score, scores in grid_result.grid_scores_:     print(&quot;%f (%f) with: %r&quot; % (scores.mean(), scores.std(), params))</code></p>
<p>10.2深度学习系统性能优化建议<br>10.2.1输入及预处理流水线优化<br>输入流水线：从磁盘读取图像，将JPEG预处理为张量，进行数据预处理裁剪、翻转等，然后进行批处理操作<br>1.在CPU端进行预处理<br>&#x2F;&#x2F;在CPU端上放置输入预处理操作可以显著提高性能，GPU专注训练<br>&#x2F;&#x2F;控制代码在CPU端执行<br><code>with tf.device(&quot;/cpu:0&quot;):     # function to get and process data. ​    distored_inputs = load_and_preprocess_images()</code></p>
<p>2.使用大文件<br>读取大量的小文件会显著影响I&#x2F;O性能<br>1）转换为TFRecord格式<br>2）小数据集加载到内存</p>
<p>10.2.2数据格式<br>NHWC的方存局部性更好（每三个输入像素即可得到一个输出像素），NCHW则必须等所有通道输入都准备好后才能得到最终的输出结果，需要占用较大的临时空间。<br>tf默认NHWC格式，Nvidia cuDNN默认NCHW格式<br>注：设计网络时充分考虑这两种格式，最好能够灵活切换，在GPU上训练时使用NCHW格式，在CPU上做预测时使用NHWC格式</p>
<p>10.2.3编译优化<br>&#x2F;&#x2F;通过bazel命令对特定平台对tf进行编译<br><code>bazel build -c opt --copt=-march=&quot;brodewell&quot; --config=cuda //tensorflow/tools/pip_package:build_pip_package</code></p>
<p>10.2.4GPU性能瓶颈诊断<br>&#x2F;&#x2F;参考如下分析步骤对作业进行优化<br>1）对代码进行性能分析<br>2）找到运行慢的阶段<br>3）分析慢的原因<br>4）修改成更快的实现<br>5）再次对代码进行性能分析</p>
<p>&#x2F;&#x2F;处理器有两个关键的性能瓶颈：浮点计算量和内存吞吐量。<br>&#x2F;&#x2F;可通过以下工具进行深度学习作业的性能分析<br>1.Tensorflow性能分析工具Timeline(获取执行图中每个节点的执行时间）<br>1）创建metadata运行时对象<br>2）获取运行时信息创建Timeline对象<br>3）将Timeline对象写入json文件<br>4）Chrome加载trace的json文件</p>
<p>&#x2F;&#x2F;tensorflow使用Timeline进行性能分析<br><code>import tensorflow as tf from tensorflow.python.client import timeline</code></p>
<p><code>x = tf.random_normal([1000, 1000]) y = tf.random_normal([1000, 1000]) res = tf.matmul(x, y)</code></p>
<p><code>#run the graph with full trace option with tf.Session() as sess:     run_options = tf.RunOptions(trace_level=tf.RunOptions.FULL_TRACE)     run_metadata = tf.RunMetadata()     sess.run(res, options=run_options, run_metadata=run_metadata)</code></p>
<pre><code>#create Timeline variable，then write it into json file
t1 = timeline.Timeline(run_metadata.step_stats)
ctf = t1.generate_chrome_trace_format()
with open(&#39;timeline.json&#39;, &#39;w&#39;) as f:
    f.write(ctf)
</code></pre>
<p>可以打开谷歌chrome浏览器，转到chrome:&#x2F;&#x2F;tracing页并加载timeline.json文件，接下来，可以进行程序的profiling</p>
<p>2.常用的GPU分析工具<br>1）nvprof是英伟达性能分析工具<br>2）nvvp则是带GUI的英伟达可视化性能分析工具</p>
<p>10.2.5CPU瓶颈优化<br>1）多线程方式优化<br>以下两个针对tensorflow的配置可以通过适配线程池进行CPU的性能优化<br>intra_op_parallelism_threads：对tf操作符内部的任务进行并行化<br>inter_op_parallelism_threads: 控制多个运算符之间的并行化运算<br>&#x2F;&#x2F;多线程优化<br><code>config = tf.ConfigProto() config.intra_op_parallelism_threads = 22 config.inter_op_parallelism_threads = 22 tf.session(config=config)</code></p>
<p>2)使用SIMD高级指令集<br>参考tf官方文档的”Performance Guide”章节</p>
<p>10.2.6模型压缩<br>模型小型化：从模型权重的角度进行压缩和从网络架构的角度进行压缩<br>网络架构角度：提出新的网络结构或卷积方法进行压缩优化，如SqueezeNet, MobileNets等<br>模型权重角度：一般是在已经训练好的模型上进行裁剪，然后fine-tuning到原有模型的准确率，一般的优化方式包括剪枝、权值共享、神经网络二值化等。</p>
<p>10.3工程实践建议<br>10.3.1Model格式转换<br>框架间的模型转换<br>参考链接：<br>1.<a href="https://github.com/ysh329/deep-learning-model-convertor">https://github.com/ysh329/deep-learning-model-convertor</a><br>2.<a href="https://github.com/Microsoft/MMdnn">https://github.com/Microsoft/MMdnn</a></p>
<p>10.3.2迁移学习（Transfer Learning)<br>其思想是将训练好的模型参数迁移到新的模型来帮助新模型的训练和预测。</p>
<p>&#x2F;&#x2F;通过MNIST数据集0<del>4的数字训练一个模型，然后将模型迁移到5</del>9数据集上进行迁移学习<br>1）在MNIST数据集上训练一个简单的卷积神经网络，只预测0<del>4的数字<br>2）将训练好的预测0</del>4数据集的模型，应用到5~9数据集上。对模型冻结卷积层参数，Fine-Tuning全连接层。<br>&#x2F;&#x2F;keras迁移学习实例<br><code>from __future__ import print_function import datetime import keras from keras.datasets import mnist from keras.models import Sequential from keras.layers import Dense, Dropout, Activation, Flatten from keras.layers import Conv2D, MaxPooling2D from keras import backend as K</code></p>
<p><code>now = datetime.datetime.now batch_size = 128 num_classes = 5 epochs = 5</code></p>
<p><code>#input images dimensions img_rows, img_cols = 28, 28 #number of convolutional filters  to use filters = 32 #size of pooling area for max pooling     pool_size = 2 #convolution kernel size kernel_size = 3</code></p>
<p><code>if K.image_data_format()==&#39;channels_first&#39;:     input_shape = (1, img_rows, img_cols) else:     input_shape = (img_rows, img_cols, 1)</code></p>
<p><code>def train_model(model, train, test, num_classes):     x_train = train[0].reshape((train[0].shape[0],)+input_shape)     x_test = test[0].reshape((test[0].shape[0],)+input_shape)     x_train = x_train.astype(&#39;float32&#39;)     x_test = x_test.astype(&#39;float32&#39;)     x_train /= 255     x_test /= 255     print(&#39;x_train shape:&#39;, x_train.shape)     print(x_train.shape[0], &#39;train samples&#39;)     print(x_test.shape[0], &#39;test samples&#39;)</code></p>
<pre><code>#convert class vectors to binary class matrics
y_train = keras.utils.to_categorical(train[1], num_classes)
y_test = keras.utils.to_categorical(test[1], num_classes)

model.compile(
    loss = &#39;categorical_crossentropy&#39;,
    optimizer = &#39;adadelta&#39;,
    metrics = [&#39;accuracy&#39;]
    )

t = now()
model.fit(x_train, y_train,
    batch_size = batch_size,
    epochs = epochs,
    verbose = 1,
    validation_data = (x_test, y_test))
print(&#39;Training time: %s&#39; %(now() -t))
score = model.evaluate(x_test, y_test, verbose=0)
print(&#39;Test score:&#39;, score[0])
</code></pre>
<p><code>#the data,shuffled and spilt between train and test sets (x_train, y_train), (x_test, y_test) = mnist.load-data() #create two datasets one with digits below 5 and one with 5 and above x_train_lt5 = x_train[y_train&lt;5] y_train_lt5 = x_train[y_train&lt;5] x_test_lt5 = x_test[y_test&lt;5] y_test_lt5 = y_test[y_test&lt;5]</code></p>
<p><code>x_train_get5 = x_train[y_train&gt;=5] y_train_get5 = y_train[y_train&gt;=5]-5 x_test_get5 = x_test[y_test&gt;=5] y_test_get5 = y_test[y_test&gt;=5]-5</code></p>
<p><code>#define two groups of layers:feature(convolutions) and classification(dense) feature_layers = [         Conv2D(filters, kernel_size,             padding=&#39;valid&#39;,             input_shape=input_shape),         Activation(&#39;relu&#39;),         Conv2D(filters, kernel_size),         Activation(&#39;relu&#39;),         MaxPooling2D(pool_size=pool_size),         Dropout(0.5),         Flatten()] classification_layers=[     Dense(128),     Activation(&#39;relu&#39;),     Dropout(0.5),     Dense(num_classes),     Activation(&#39;softmax&#39;)]</code></p>
<p><code>#create complete model model = Sequential(feature_layers+classification_layers)</code></p>
<p><code>#train model for 5-digit classification(0~4) train_model(model,     (x_train_lt5, y_train_lt5),     (x_test_lt5, y_test_lt5), num_classes)</code></p>
<p><code>#freeze feature layers and rebuild model for l in feature_layers:     l.trainable = False</code></p>
<p><code>#transfer: train dense layers for new classification task(5~9) train_model(model,     (x_train_gte5, y_train_get5),     (x_test_get5, y_test_get5), num_classes)</code></p>
<p>​<br>​<br>​    </p>
]]></content>
  </entry>
  <entry>
    <title>色彩搭配</title>
    <url>/2022/03/22/en/%E6%95%99%E4%BD%A0%E5%AD%A6%E4%BC%9A%E8%89%B2%E5%BD%A9%E6%90%AD%E9%85%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="中国色"><a href="#中国色" class="headerlink" title="中国色"></a>中国色</h3><p><a href="http://zhongguose.com/">中国色</a></p>
<h3 id="COULEUR"><a href="#COULEUR" class="headerlink" title="COULEUR"></a>COULEUR</h3><p><a href="https://www.code-couleur.com/signification/">couleur</a></p>
<h3 id="color-space"><a href="#color-space" class="headerlink" title="color space"></a>color space</h3><p><a href="https://mycolor.space/">color space</a></p>
<h3 id="hyper-color"><a href="#hyper-color" class="headerlink" title="hyper color"></a>hyper color</h3><p><a href="https://hypercolor.dev/">Hypercolor</a></p>
<h3 id="colorable"><a href="#colorable" class="headerlink" title="colorable"></a>colorable</h3><p><a href="https://colorable.jxnblk.com/">Colorable</a></p>
<h3 id="brandcolors"><a href="#brandcolors" class="headerlink" title="brandcolors"></a>brandcolors</h3><p><a href="https://brandcolors.net/">BrandColors</a></p>
<h3 id="九月ppt"><a href="#九月ppt" class="headerlink" title="九月ppt"></a>九月ppt</h3><p><a href="https://jiuyueppt.com/#/">九月PPT</a></p>
<h3 id="huemint"><a href="#huemint" class="headerlink" title="huemint"></a>huemint</h3><p><a href="https://huemint.com/">Huemint - AI color palette generator</a></p>
<h3 id="Adobe-Color"><a href="#Adobe-Color" class="headerlink" title="Adobe Color"></a>Adobe Color</h3><p><a href="https://color.adobe.com/zh/create/color-wheel">色輪、調色盤產生器 | Adobe Color</a></p>
]]></content>
  </entry>
  <entry>
    <title>文献阅读笔记</title>
    <url>/2022/04/08/en/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.DetNet</p>
<p>2.SNIP</p>
]]></content>
  </entry>
  <entry>
    <title>数据处理</title>
    <url>/2022/04/14/en/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="单进程"><a href="#单进程" class="headerlink" title="单进程"></a>单进程</h2><p>​        在单进程模式下，DataLoader 初始化的进程和取数据的进程是一样的 。因此，数据加载可能会阻止计算。但是，当用于在进程之间共享数据的资源（例如共享内存，文件描述符）有限时，或者当整个数据集很小并且可以完全加载到内存中时，此模式可能是我们首选。此外，单进程加载通常可以显示更多可读的错误跟踪，这<strong>对于我们调试代码很有用</strong>。</p>
<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>·多进程处理</p>
<p>​        为了避免在加载数据时阻塞计算，PyTorch 提供了一个简单的开关，只需将参数设置 num_workers 为正整数即可执行多进程数据加载，而设置为 0 时执行单线程数据加载。</p>
<p>​        在设置多进程模式时，每次 DataLoader 创建 iterator 时（例如，当调用 enumerate(dataloader) 时），都会创建 num_workers 个工作进程。此时dataset, collate_fn, worker_init_fn 都会被传到每个worker中，而每个 worker 都用独立的进程。</p>
<p>​        对于 map-style 数据，主线程会用 Sampler 产生 indices，并将它们送到 worker 里。因此，shuffle 是在主线程做的。</p>
<p>​        而对于 iterable-style 数据，因为每个 worker 都有相同的 data 复制样本，并在各个进程里进行不同的操作，以防止每个进程输出的数据是重复的，所以一般会使用 torch.utils.data.get_worker_info() 来进行辅助处理。这里，torch.utils.data.get_worker_info() 会返回 worker 进程的一些信息(如id, dataset, num_workers, seed)，如果在主线程的话返回 None。</p>
<p>​        <strong>注意</strong>，通常不建议在多进程加载中返回 CUDA 张量，因为在使用 CUDA 和在多处理中共享 CUDA 张量时存在许多微妙之处（文档中提出：只要接收过程保留张量的副本，就需要发送过程来保留原始张量）。建议采用 pin_memory&#x3D;True ，以将数据快速传输到支持 CUDA 的 GPU。简而言之，<strong>不建议在使用多线程的情况下返回 CUDA 的 Tensor</strong>。</p>
<h2 id="锁页内存"><a href="#锁页内存" class="headerlink" title="锁页内存"></a>锁页内存</h2><p>​        首先我们先了解一下锁页内存的概念。</p>
<p>​        主机中的内存，有两种存在方式，一是锁页，二是不锁页。锁页内存存放的内容在任何情况下都不会与主机的虚拟内存进行交换（注：虚拟内存就是硬盘），而不锁页内存在主机内存不足时，数据会存放在虚拟内存中。主机到 GPU 副本源自固定（页面锁定）内存时，速度要快得多。CPU 张量和存储暴露了一种 pin_memory() 方法，该方法返回对象的副本，并将数据放在固定的区域中。</p>
<p>​        <strong>而显卡中的显存全部是锁页内存！当计算机的内存充足的时候，可以设置 pin_memory&#x3D;True</strong>。设置 pin_memory&#x3D;True，则意味着生成的 Tensor 数据最开始是属于内存中的锁页内存，这样将内存的 Tensor 转义到 GPU 的显存就会更快一些。同时，由于 pin_memory 的作用是将张量返回之前将其复制到 CUDA 固定的内存中，所以只有在 CUDA 环境支持下才有用。</p>
<p>​        PyTorch 原生的 pin_memory 方法如下，其支持大部分 python 数据类型的处理：</p>
<pre><code class="python">def pin_memory(data):
    if isinstance(data, torch.Tensor):
        return data.pin_memory()
    elif isinstance(data, string_classes):
        return data
    elif isinstance(data, container_abcs.Mapping):
        return &#123;k: pin_memory(sample) for k, sample in data.items()&#125;
    elif isinstance(data, tuple) and hasattr(data, &#39;_fields&#39;):  # namedtuple
        return type(data)(*(pin_memory(sample) for sample in data))
    elif isinstance(data, container_abcs.Sequence):
        return [pin_memory(sample) for sample in data]
    elif hasattr(data, &quot;pin_memory&quot;):
        return data.pin_memory()
    else:
        return data
</code></pre>
<p>​        默认情况下，如果固定逻辑对于一个属于自定义类型（custom type）的 batch（如果有一个 collate_fn 返回自定义批处理类型的批处理，则会发生），或者如果该批处理的每个元素都是 custom type，则该固定逻辑将无法识别它们，它会返回该批处理（或那些元素）而无需固定内存。而要为自定义批处理或数据类型启用内存固定，我们需使用 pin_memory() 在自定义类型上自定义一个方法。如下：</p>
<pre><code class="python">class SimpleCustomBatch:
    # 自定义一个类，该类不能被PyTorch原生的pin_memory方法所支持

    def __init__(self, data):
        transposed_data = list(zip(*data))
        self.inp = torch.stack(transposed_data[0], 0)
        self.tgt = torch.stack(transposed_data[1], 0)

    # custom memory pinning method on custom type
    def pin_memory(self):
        self.inp = self.inp.pin_memory()
        self.tgt = self.tgt.pin_memory()
        return self

def collate_wrapper(batch):
    return SimpleCustomBatch(batch)

inps = torch.arange(10 * 5, dtype=torch.float32).view(10, 5)
tgts = torch.arange(10 * 5, dtype=torch.float32).view(10, 5)
dataset = TensorDataset(inps, tgts)

loader = DataLoader(dataset, batch_size=2, collate_fn=collate_wrapper,
                    pin_memory=True)

for batch_ndx, sample in enumerate(loader):
    print(sample.inp.is_pinned())  # True
    print(sample.tgt.is_pinned())  # True
</code></pre>
<h2 id="预取"><a href="#预取" class="headerlink" title="预取"></a>预取</h2><p>DataLoader 通过指定 prefetch_factor （默认为 2）来进行数据的预取。</p>
<pre><code class="python">class _MultiProcessingDataLoaderIter(_BaseDataLoaderIter):
    def __init__(self, loader):
        ...
        self._reset(loader, first_iter=True)

    def _reset(self, loader, first_iter=False):
        ...
        # prime the prefetch loop
        for _ in range(self._prefetch_factor * self._num_workers):
            self._try_put_index()
</code></pre>
<p>通过源码可以看到，prefetch 功能仅适用于多进程加载中（下面也会有多进程 dataloader 的部分代码分析）。</p>
<h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><p>那么现在让我们来看看具体的代码调用流程：</p>
<pre><code class="python">for data, label in train_loader:
    ......
</code></pre>
<p>for 循环会调用 dataloader 的 <strong><strong>iter</strong>(self)</strong> 方法，以此获得迭代器来遍历 dataset。</p>
<pre><code class="python">class DataLoader(Generic[T_co]):
    ...
    def __iter__(self) -&gt; &#39;_BaseDataLoaderIter&#39;:

        if self.persistent_workers and self.num_workers &gt; 0:
            if self._iterator is None:
                self._iterator = self._get_iterator()
            else:
                self._iterator._reset(self)
            return self._iterator
        else:
            return self._get_iterator()
</code></pre>
<p>在 <strong><strong>iter</strong>(self)</strong> 方法中，dataloader 调用了 self._get_iterator() 方法，根据 num_workers 获得迭代器，并指示是进行单进程还是多进程处理。</p>
<pre><code class="python">class DataLoader(Generic[T_co]):
    ...
    def _get_iterator(self) -&gt; &#39;_BaseDataLoaderIter&#39;:
        if self.num_workers == 0:
            return _SingleProcessDataLoaderIter(self)
        else:
            self.check_worker_number_rationality()
            return _MultiProcessingDataLoaderIter(self)
</code></pre>
<p>为了描述更加清晰，我们只考虑单进程的代码。下面是 class _SingleProcessDataLoaderIter(_BaseDataLoaderIter) ，以及其父类 class _BaseDataLoaderIter(object): 的重点代码片段：</p>
<pre><code class="python">
class _BaseDataLoaderIter(object):
    def __init__(self, loader: DataLoader) -&gt; None:
        # 初始化赋值一些 DataLoader 参数，
        # 以及用户输入合法性进行校验
        self._dataset = loader.dataset
        self._dataset_kind = loader._dataset_kind
        self._index_sampler = loader._index_sampler
        ...

    def __iter__(self) -&gt; &#39;_BaseDataLoaderIter&#39;:
        return self

    def _reset(self, loader, first_iter=False):
        self._sampler_iter = iter(self._index_sampler)
        self._num_yielded = 0
        self._IterableDataset_len_called = loader._IterableDataset_len_called

    def _next_index(self):
        return next(self._sampler_iter)  # may raise StopIteration

    def _next_data(self):
        raise NotImplementedError

    def __next__(self) -&gt; Any:
        with torch.autograd.profiler.record_function(self._profile_name):
            if self._sampler_iter is None:
                self._reset()
            data = self._next_data() # 重点代码行，通过此获取数据
            self._num_yielded += 1
            ...
            return data

    next = __next__  # Python 2 compatibility

    def __len__(self) -&gt; int:
        return len(self._index_sampler) # len(_BaseDataLoaderIter) == len(self._index_sampler)

    def __getstate__(self):
        raise NotImplementedError(&quot;&#123;&#125; cannot be pickled&quot;, self.__class__.__name__)
</code></pre>
<p>_BaseDataLoaderIter 是所有 DataLoaderIter 的父类。dataloader获得了迭代器之后，for 循环需要调用 <strong><strong>next</strong>()</strong> 来获得下一个对象，从而实现遍历。通过 <strong><strong>next</strong>()</strong> 方法调用 _next_data() 获取数据。</p>
<pre><code class="python">class _SingleProcessDataLoaderIter(_BaseDataLoaderIter):
    def __init__(self, loader):
        super(_SingleProcessDataLoaderIter, self).__init__(loader)
        assert self._timeout == 0
        assert self._num_workers == 0

        self._dataset_fetcher = _DatasetKind.create_fetcher(
            self._dataset_kind, self._dataset, self._auto_collation, self._collate_fn, self._drop_last)

    def _next_data(self):
        index = self._next_index()  # may raise StopIteration
        data = self._dataset_fetcher.fetch(index)  # may raise StopIteration
        if self._pin_memory:
            data = _utils.pin_memory.pin_memory(data)
        return data
</code></pre>
<p>从 _SingleProcessDataLoaderIter 的初始化参数可以看到，其在父类 _BaseDataLoaderIter 的基础上定义了 _dataset_fetcher，并传入 _dataset，_auto_collation，_collate_fn 等参数，用于定义获取数据的方式。其具体实现会在稍后解释。</p>
<p>在 _next_data() 被调用后，其需要 _next_index() 获取 index，并通过获得的 index 传入 _dataset_fetcher 中获取对应样本。</p>
<pre><code class="python">class DataLoader(Generic[T_co]):
    ...
    @property
    def _auto_collation(self):
        return self.batch_sampler is not None

    @property
    def _index_sampler(self):
        if self._auto_collation:
            return self.batch_sampler
        else:
            return self.sampler

class _BaseDataLoaderIter(object):
    ...
    def _reset(self, loader, first_iter=False):
        self._sampler_iter = iter(self._index_sampler)
        ...

    def _next_index(self):
        # sampler_iter 来自于 index_sampler
        return next(self._sampler_iter)  # may raise StopIteration
</code></pre>
<p>从这里看出，dataloader 提供了 sampler（可以是batch_sampler 或者是其他 sampler 子类），然后 _SingleProcessDataLoaderIter 迭代 sampler 获得索引。</p>
<p>下面我们来看看 fetcher，fetcher 需要 index 来获取元素，并同时支持 Map-style dataset（对应 _MapDatasetFetcher）和 Iterable-style dataset（对应 _IterableDatasetFetcher），使其在 Dataloader 内能使用相同的接口 fetch，代码更加简洁。</p>
<p>· 对于 Map-style：直接输入索引 index，作为 map 的 key，获得对应的样本（即 value）。</p>
<pre><code class="python">class _MapDatasetFetcher(_BaseDatasetFetcher):
    def __init__(self, dataset, auto_collation, collate_fn, drop_last):
        super(_MapDatasetFetcher, self).__init__(dataset, auto_collation, collate_fn, drop_last)

    def fetch(self, possibly_batched_index):
        if self.auto_collation:
            # 有batch_sampler，_auto_collation就为True，
            # 就优先使用batch_sampler，对应在fetcher中传入的就是一个batch的索引
            data = [self.dataset[idx] for idx in possibly_batched_index]
        else:
            data = self.dataset[possibly_batched_index]
        return self.collate_fn(data)
</code></pre>
<p>· 对于 Iterable-style: <strong><strong>init</strong></strong> 方法内设置了 dataset 初始的迭代器，fetch 方法内获取元素，此时 index 其实已经没有多大作用了。</p>
<pre><code class="python">class _IterableDatasetFetcher(_BaseDatasetFetcher):
    def __init__(self, dataset, auto_collation, collate_fn, drop_last):
        super(_IterableDatasetFetcher, self).__init__(dataset, auto_collation, collate_fn, drop_last)
        self.dataset_iter = iter(dataset)

    def fetch(self, possibly_batched_index):
        if self.auto_collation:
            # 对于batch_sampler（即auto_collation==True）
            # 直接使用往后遍历并提取len(possibly_batched_index)个样本（即1个batch的样本）
            data = []
            for _ in possibly_batched_index:
                try:
                    data.append(next(self.dataset_iter))
                except StopIteration:
                    break
            if len(data) == 0 or (self.drop_last and len(data) &lt; len(possibly_batched_index)):
                raise StopIteration
        else:
            # 对于sampler，直接往后遍历并提取1个样本
            data = next(self.dataset_iter)
        return self.collate_fn(data)
</code></pre>
<p>最后，我们通过索引传入 fetcher，fetch 得到想要的样本。因此，整个过程调用关系总结如下：</p>
<pre><code>loader.iter --&gt; self._get_iterator() --&gt; class _SingleProcessDataLoaderIter --&gt; class _BaseDataLoaderIter --&gt; __next__() --&gt; self._next_data() --&gt; self._next_index() --&gt;next(self._sampler_iter) 即 next(iter(self._index_sampler)) --&gt; 获得 index --&gt; self._dataset_fetcher.fetch(index) --&gt; 获得 data
</code></pre>
<p>而对于多进程而言，借用 PyTorch 内源码的注释，其运行流程解释如下：</p>
<pre><code>
# Our data model looks like this (queues are indicated with curly brackets):
#
#                main process                              ||
#                     |                                    ||
#               &#123;index_queue&#125;                              ||
#                     |                                    ||
#              worker processes                            ||     DATA
#                     |                                    ||
#            &#123;worker_result_queue&#125;                         ||     FLOW
#                     |                                    ||
#      pin_memory_thread of main process                   ||   DIRECTION
#                     |                                    ||
#               &#123;data_queue&#125;                               ||
#                     |                                    ||
#                data output                               \/
#
# P.S. `worker_result_queue` and `pin_memory_thread` part may be omitted if
#      `pin_memory=False`.
</code></pre>
<p>首先 dataloader 基于 multiprocessing 产生多进程，每个子进程的输入输出通过两个主要的队列（multiprocessing.Queue() 类）产生，分别为：</p>
<p>· index_queue：每个子进程的队列中需要处理的任务的下标</p>
<p>· _worker_result_queue：返回时处理完任务的下标</p>
<p>· data_queue：表明经过 pin_memory 处理后的数据队列</p>
<p>并且有以下这些比较重要的 flag 参数来协调各个 worker 之间的工作：</p>
<p>· _send_idx: 发送索引，用来记录这次要放 index_queue 中 batch 的 idx</p>
<p>· _rcvd_idx: 接受索引，记录要从 data_queue 中取出的 batch 的 idx</p>
<p>· _task_info: 存储将要产生的 data 信息的 dict，key为 task idx（由 0 开始的整形索引），value 为 (worker_id,) 或 (worker_id, data)，分别对应数据未取和已取的情况</p>
<p>· _tasks_outstanding: 整形，代表已经准备好的 task&#x2F;batch 的数量（可能有些正在准备中）</p>
<p>每个 worker 一次产生一个 batch 的数据，返回 batch 数据前放入下一个批次要处理的数据下标，对应构造函数子进程初始化如下：</p>
<pre><code class="python">
class _MultiProcessingDataLoaderIter(_BaseDataLoaderIter):
    def __init__(self, loader):
        super(_MultiProcessingDataLoaderIter, self).__init__(loader)
        ...
        self._worker_result_queue = multiprocessing_context.Queue()  # 把该worker取出的数放入该队列，用于进程间通信
        ...
        self._workers_done_event = multiprocessing_context.Event()
        self._index_queues = []
        self._workers = []
        for i in range(self._num_workers):
            index_queue = multiprocessing_context.Queue()  # 索引队列，每个子进程一个队列放要处理的下标
            index_queue.cancel_join_thread()
            # _worker_loop 的作用是：从index_queue中取索引，然后通过collate_fn处理数据，
            # 然后再将处理好的 batch 数据放到 data_queue 中。（发送到队列中的idx是self.send_idx）
            w = multiprocessing_context.Process(
                target=_utils.worker._worker_loop,  # 每个worker子进程循环执行的函数，主要将数据以(idx, data)的方式传入_worker_result_queue中
                args=(self._dataset_kind, self._dataset, index_queue, 
                      self._worker_result_queue, self._workers_done_event,
                      self._auto_collation, self._collate_fn, self._drop_last,
                      self._base_seed + i, self._worker_init_fn, i, self._num_workers,
                      self._persistent_workers))
            w.daemon = True
            w.start()
            self._index_queues.append(index_queue)
            self._workers.append(w)
        if self._pin_memory:
            self._pin_memory_thread_done_event = threading.Event()
            self._data_queue = queue.Queue()  # 用于存取出的数据进行 pin_memory 操作后的结果
            pin_memory_thread = threading.Thread(
                target=_utils.pin_memory._pin_memory_loop,
                args=(self._worker_result_queue, self._data_queue,
                      torch.cuda.current_device(),
                      self._pin_memory_thread_done_event))
            pin_memory_thread.daemon = True
            pin_memory_thread.start()
            # Similar to workers (see comment above), we only register
            # pin_memory_thread once it is started.
            self._pin_memory_thread = pin_memory_thread
        else:
            self._data_queue = self._worker_result_queue
        ...
        self._reset(loader, first_iter=True)
    def _reset(self, loader, first_iter=False):
        super()._reset(loader, first_iter)
        self._send_idx = 0  # idx of the next task to be sent to workers，发送索引，用来记录这次要放 index_queue 中 batch 的 idx
        self._rcvd_idx = 0  # idx of the next task to be returned in __next__，接受索引，记录要从 data_queue 中取出的 batch 的 idx
        # information about data not yet yielded, i.e., tasks w/ indices in range [rcvd_idx, send_idx).
        # map: task idx =&gt; - (worker_id,)        if data isn&#39;t fetched (outstanding)
        #                  \ (worker_id, data)   if data is already fetched (out-of-order)
        self._task_info = &#123;&#125;
        # _tasks_outstanding 指示当前已经准备好的 task/batch 的数量（可能有些正在准备中）
        # 初始值为 0, 在 self._try_put_index() 中 +1,在 self._next_data 中-1
        self._tasks_outstanding = 0  # always equal to count(v for v in task_info.values() if len(v) == 1)
        # this indicates status that a worker still has work to do *for this epoch*.
        self._workers_status = [True for i in range(self._num_workers)] 
        # We resume the prefetching in case it was enabled
        if not first_iter:
            for idx in range(self._num_workers):
                self._index_queues[idx].put(_utils.worker._ResumeIteration())
            resume_iteration_cnt = self._num_workers
            while resume_iteration_cnt &gt; 0:
                data = self._get_data()
                if isinstance(data, _utils.worker._ResumeIteration):
                    resume_iteration_cnt -= 1
        ...
        # 初始化的时候，就将 2*num_workers 个 (batch_idx, sampler_indices) 放到 index_queue 中
        for _ in range(self._prefetch_factor * self._num_workers):
            self._try_put_index() # 进行预取
</code></pre>
<p>dataloader 初始化的时候，每个 worker 的 index_queue 默认会放入<strong>两个</strong> batch 的 index，从 index_queue 中取出要处理的下标。</p>
<pre><code class="python">def _try_put_index(self):
        # self._prefetch_factor 默认为 2
        assert self._tasks_outstanding &lt; self._prefetch_factor * self._num_workers
        try:
            index = self._next_index()
        except StopIteration:
            return
        for _ in range(self._num_workers):  # find the next active worker, if any
            worker_queue_idx = next(self._worker_queue_idx_cycle)
            if self._workers_status[worker_queue_idx]:
                break
        else:
            # not found (i.e., didn&#39;t break)
            return
        self._index_queues[worker_queue_idx].put((self._send_idx, index)) # 放入 任务下标 和 数据下标
        self._task_info[self._send_idx] = (worker_queue_idx,)
        # _tasks_outstanding + 1，表明预备好的batch个数+1
        self._tasks_outstanding += 1
        # send_idx 发送索引, 记录从sample_iter中发送索引到index_queue的次数
        self._send_idx += 1
</code></pre>
<p>调用 _next_data(self) 方法进行数据读取，其中 _process_data(self, data) 用于返回数据。</p>
<pre><code class="python">
def _next_data(self):
        while True:

            while self._rcvd_idx &lt; self._send_idx: # 确保待处理的任务(待取的batch)下标 &gt; 处理完毕要返回的任务(已经取完的batch)下标
                info = self._task_info[self._rcvd_idx]
                worker_id = info[0]
                if len(info) == 2 or self._workers_status[worker_id]:  # has data or is still active
                    break
                del self._task_info[self._rcvd_idx]
                self._rcvd_idx += 1
            else:
                # no valid `self._rcvd_idx` is found (i.e., didn&#39;t break)
                if not self._persistent_workers:
                    self._shutdown_workers()
                raise StopIteration

            # Now `self._rcvd_idx` is the batch index we want to fetch

            # Check if the next sample has already been generated
            if len(self._task_info[self._rcvd_idx]) == 2:
                data = self._task_info.pop(self._rcvd_idx)[1]
                return self._process_data(data)

            assert not self._shutdown and self._tasks_outstanding &gt; 0
            idx, data = self._get_data() # 调用 self._try_get_data() 从 self._data_queue 中取数
            self._tasks_outstanding -= 1  # 表明预备好的batch个数需要减1
            if self._dataset_kind == _DatasetKind.Iterable:
                # Check for _IterableDatasetStopIteration
                if isinstance(data, _utils.worker._IterableDatasetStopIteration):
                    if self._persistent_workers:
                        self._workers_status[data.worker_id] = False
                    else:
                        self._mark_worker_as_unavailable(data.worker_id)
                    self._try_put_index()
                    continue

            if idx != self._rcvd_idx:
                # store out-of-order samples
                self._task_info[idx] += (data,)
            else:
                del self._task_info[idx]
                return self._process_data(data) # 返回数据

    def _process_data(self, data):
        self._rcvd_idx += 1
        self._try_put_index() # 同上，主要放入队列索引 以及 更新flag
        if isinstance(data, ExceptionWrapper):
            data.reraise()
        return data
</code></pre>
<p>这样，多进程模式的 dataloader 就能通过多个 worker 的协作来共同完成数据的加载。</p>
]]></content>
      <categories>
        <category>pytorch</category>
        <category>data processing</category>
      </categories>
      <tags>
        <tag>数据处理</tag>
      </tags>
  </entry>
</search>
